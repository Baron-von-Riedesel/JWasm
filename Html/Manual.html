<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 FINAL//EN">
<HTML>
<HEAD>
<TITLE> JWasm Manual </TITLE>
</HEAD>
<BODY>
 
<H1 ID="CHAPCONTENTS">    0. Contents </H1>
<DL> 
<DD>    1.    <A HREF="#CHAPABOUT">About</A></DD>
<DD>    2.    <A HREF="#CHAPCMDOPT">Commandline Options</A></DD>
<DL>
<DD>          <A HREF="#CMDOPTCPU">Options -0, -1, -2,  ..., -10</A></DD>
<DD>          <A HREF="#CMDOPTBIN">Option -bin</A></DD>
<DD>          <A HREF="#CMDOPTCOFF">Option -coff</A></DD>
<DD>          <A HREF="#CMDOPTDJGPP">Option -djgpp</A></DD>
<DD>          <A HREF="#CMDOPTE">Option -e</A></DD>
<DD>          <A HREF="#CMDOPTELF">Option -elf</A></DD>
<DD>          <A HREF="#CMDOPTELF64">Option -elf64</A></DD>
<DD>          <A HREF="#CMDOPTEQ">Option -eq</A></DD>
<DD>          <A HREF="#CMDOPTFD">Option -Fd</A></DD>
<DD>          <A HREF="#CMDOPTFPI">Option -FPi</A></DD>
<DD>          <A HREF="#CMDOPTFW">Option -Fw</A></DD>
<DD>          <A HREF="#CMDOPTGCDRZ">Options -Gc, -Gd, -Gr, -Gz</A></DD>
<DD>          <A HREF="#CMDOPTM">Option -m</A></DD>
<DD>          <A HREF="#CMDOPTMZ">Option -mz</A></DD>
<DD>          <A HREF="#CMDOPTNC">Option -nc</A></DD>
<DD>          <A HREF="#CMDOPTNDNT">Options -nd, -nt</A></DD>
<DD>          <A HREF="#CMDOPTNM">Option -nm</A></DD>
<DD>          <A HREF="#CMDOPTPE">Option -pe</A></DD>
<DD>          <A HREF="#CMDOPTWIN64">Option -win64</A></DD>
<DD>          <A HREF="#CMDOPTZC">Option -zc</A></DD>
<DD>          <A HREF="#CMDOPTZD">Option -Zd</A></DD>
<DD>          <A HREF="#CMDOPTZF">Option -zf</A></DD>
<DD>          <A HREF="#CMDOPTZG">Option -Zg</A></DD>
<DD>          <A HREF="#CMDOPTZI">Option -Zi</A></DD>
<DD>          <A HREF="#CMDOPTZLOMF">Options -zlc and -zld</A></DD>
<DD>          <A HREF="#CMDOPTZLCOFF">Options -zlf, -zlp and zls</A></DD>
<DD>          <A HREF="#CMDOPTZM">Option -Zm</A></DD>
<DD>          <A HREF="#CMDOPTZNE">Option -Zne</A></DD>
<DD>          <A HREF="#CMDOPTZT">Option -zt</A></DD>
<DD>          <A HREF="#CMDOPTZV8">Option -Zv8</A></DD>
<DD>          <A HREF="#CMDOPTZZE">Option -zze</A></DD>
<DD>          <A HREF="#CMDOPTZZS">Option -zzs</A></DD>
</DL>
<DD>    3.    <A HREF="#CHAPSYNTAXEXT">Syntax Extensions</A></DD>
<DL>
<DD>     3.1  <A HREF="#DIRINCBIN">Directive INCBIN</A></DD>
<DD>     3.2  <A HREF="#CALLCONVFASTCALL">FASTCALL Register Calling Convention</A></DD>
<DD>     3.3  <A HREF="#BACKQUOTEIDS">IDs enclosed in Back Quotes</A></DD>
<DD>     3.4  <A HREF="#FPIMMEDIATE">Floating-Point Immediates in Instructions</A></DD>
<DD>     3.5  <A HREF="#OPTFIELDALIGN">Directive OPTION FIELDALIGN</A></DD>
<DD>     3.6  <A HREF="#OPTPROCALIGN">Directive OPTION PROCALIGN</A></DD>
<DD>     3.7  <A HREF="#OPTMZ">Directive OPTION MZ</A></DD>
<DD>     3.8  <A HREF="#OPTELF">Directive OPTION ELF</A></DD>
<DD>     3.9  <A HREF="#OPTWIN64">Directive OPTION WIN64</A></DD>
<DD>     3.10 <A HREF="#OPTFRAME">Directive OPTION FRAME</A></DD>
<DD>     3.11 <A HREF="#OPTRENAMEKEYWORD">Directive OPTION RENAMEKEYWORD</A></DD>
<DD>     3.12 <A HREF="#OPTDLLIMPORT">Directive OPTION DLLIMPORT</A></DD>
<DD>     3.13 <A HREF="#OPTCODEVIEW">Directive OPTION CODEVIEW</A></DD>
<DD>     3.14 <A HREF="#OPTSTACKBASE">Directive OPTION STACKBASE</A></DD>
<DD>     3.15 <A HREF="#DIRPUSHCONTEXT">Directives PUSHCONTEXT / POPCONTEXT ALIGNMENT</A></DD>
<DD>     3.16 <A HREF="#DIRX64">Directives .X64 and .X64p</A></DD>
<DD>     3.17 <A HREF="#LABELATTR">Attribute LABEL for first Macro Parameter</A></DD>
<DD>     3.18 <A HREF="#MBRARG">Member Argument for IF[N]DEF and .ERR[N]DEF</A></DD>
<DD>     3.19 <A HREF="#INITMMXMM">Initialization of Data Items of Type MMWORD/XMMWORD</A></DD>
<DD>     3.20 <A HREF="#LABELARRAY">Optional Array Size for LABEL Directive</A></DD>
<DD>     3.21 <A HREF="#SIMSEGARG">Optional Name Argument for Simplified Segment Directives</A></DD>
<DD>     3.22 <A HREF="#ATTRCOMDAT">Segment Attribute COMDAT</A></DD>
<DD>     3.23 <A HREF="#VARARGMLATTR">Attribute VARARGML for last Macro Parameter</A></DD>
<DD>     3.24 <A HREF="#OTHERDIFF">Miscellaneous</A></DD>
<DL>
<DD>     3.24.1 <A HREF="#OTHERDIFF1">Numeric constant __JWASM__</A></DD>
<DD>     3.24.2 <A HREF="#OTHERDIFF2">Operating System Argument for .MODEL</A></DD>
<DD>     3.24.3 <A HREF="#OTHERDIFF3">Accepted Parameters for IF[N]DEF Directive</A></DD>
<DD>     3.24.4 <A HREF="#OTHERDIFF4">Visibility of Procedures</A></DD>
<DD>     3.24.5 <A HREF="#OTHERDIFF5">Non-RIP-Relative Addressing in 64-Bit</A></DD>
</DL>
</DL>
<DD>    4.    <A HREF="#CHAPINSTRSET">Instruction Sets</A></DD>
<DD>    5.    <A HREF="#CHAPCODEGENDIFF">Code Generation Differences</A></DD>
<DL>
<DD>     5.1  <A HREF="#FWDREFINMACRO">Forward References in Macro Expressions</A></DD>
</DL>
<DD>    6.    <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A></DD>
<DL>
<DD>    6.1   <A HREF="#OUTPUTFORMATOMF">OMF Output Format</A></DD>
<DD>    6.2   <A HREF="#OUTPUTFORMATCOFF">COFF Output Format</A></DD>
<DD>    6.3   <A HREF="#OUTPUTFORMATWIN64">Win64 Output Format</A></DD>
<DD>    6.4   <A HREF="#OUTPUTFORMATBIN">Binary Output Format</A></DD>
<DD>    6.5   <A HREF="#OUTPUTFORMATPE">PE Output Format</A></DD>
</DL>
<DD>    7.    <A HREF="#CHAPMASMBUGS">Masm Bugs fixed in JWasm</A></DD>
<DD>    8.    <A HREF="#CHAPOPTFEAT">Optional Features</A></DD>
<DD>    9.    <A HREF="#CHAPKNOWNBUGS">Known Bugs and missing Features</A></DD>
<DD>    10.   <A HREF="#CHAPLICENSE">License</A></DD>
<DD>    Appendix A. <A HREF="#AA">Reserved Words</A></DD>
<DD>    Appendix B. <A HREF="#AB">Source Samples</A></DD>
<DD>    Appendix C. <A HREF="#AC">Errors and Warnings</A></DD>
<DD>    Appendix D. <A HREF="#AD">Differences between Masm 6 and Masm 8</A></DD>
<DD>    Appendix E. <A HREF="#AE">Restrictions of precommpiled 16-bit Binary JWASMR.EXE</A></DD>
<DD>    Appendix F. <A HREF="#AF">Additional Features of JWasm's Debug Version</A></DD>
</DL>

<H1 ID="CHAPABOUT">    1. About </H1>
 
    This document lists the differences between JWasm and Masm, as far as
    the user interface is concerned.
<P> 
    When Masm is mentioned, then usually Masm v8.00 is meant, unless stated
    otherwise. Masm v8.00 also was the first Masm version supporting 64-bit
    (ML64.EXE).
<P> 
    The Masm documentation itself can be found on numerous places in the web,
    in plain text, HTML, PDF and Windows Help format. However, it's usually
    just the documentation that came whith Masm v6.1 - hence a bit outdated
    nowadays ( the changes from Masm v6 to Masm v8 are listed in
    <A HREF="#AD">Appendix D</A> ).
<P> 

<H1 ID="CHAPCMDOPT">    2. Commandline Options </H1>
 
    Entering 'JWasm -?' or 'JWasm -h' will make JWasm display the options
    it understands. A lot of them exist in both Masm and JWasm, but some
    are valid for JWasm only; OTOH, a few options are missing in JWasm.
<P> 
    Options are usually entered via the command line. Additionally, when
    starting, JWasm will search for <b>environment variable JWASM</b>
    and handle it similar to the way Masm handles variable ML. Hence it is
    also possible to enter options via this method.
<P> 
    The options specific to JWasm - and also the options which are handled
    somewhat differently by JWasm compared to Masm - will be handled in the
    following chapters.
<P> 
    One major difference should be mentioned here: JWasm does never launch a
    linker on its own ( which Masm does unless option -c is given ). This
    makes a few Masm options useless for JWasm, and hence they are not implemented;
    see Chapter <A HREF="#CHAPKNOWNBUGS">Known Bugs and missing Features</A> for
    details.

<H2 ID="CMDOPTCPU">    Options -0, -1, -2,  ..., -10: Select Cpu </H2>
 
    Option [0|1|..|10] selects cpu/instruction set. Most values correspond to
    cpu directives: 
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
  <TR BGCOLOR="#E8E8E8"><TD> 0</TD><TD>.8086 </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 1</TD><TD>.186  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 2</TD><TD>.286  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 3</TD><TD>.386  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 4</TD><TD>.486  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 5</TD><TD>.586  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 6</TD><TD>.686  </TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 7</TD><TD>.686 and .MMX (P2)</TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 8</TD><TD>.686, .MMX and SSE instructions (P3)</TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD> 9</TD><TD>.686, .MMX, SSE and SSE2 instructions (P4)</TD></TR>
  <TR BGCOLOR="#E8E8E8"><TD>10</TD><TD>.x64 (x86-64 cpu)</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<H2 ID="CMDOPTBIN">    Option -bin: Select Output Format Binary </H2>
 
    Option -bin selects output format BINary. The output module's default file
    extension will be changed from .OBJ to .BIN. 
<P> 
    For more information, see <A HREF="#OUTPUTFORMATBIN">Binary Output Format</A>.
<P> 
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTCOFF">    Option -coff: Select Output Format COFF </H2>
 
    Option -coff selects output format COFF. The most common use for -coff is to produce
    modules for 32-bit Windows. However, it's not mandatory that the output will be 32-bit with -coff; 
    depending on what cpu is selected when the .MODEL directive will be parsed, the output may be
    32- or 64-bit. 
<P>
    For more information about COFF, see <A HREF="#OUTPUTFORMATCOFF">COFF Output Format</A>.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTDJGPP">    Option -djgpp: Select Output Format for DJGPP (optional) </H2>

    Option -djgpp selects Djgpp's variant of COFF as output format.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.


<H2 ID="CMDOPTE">    Option -e: Set error limit </H2>

    Allows to set the number of errors after which the assembly process is aborted. 
    The default value is 50.

<H2 ID="CMDOPTELF">    Option -elf: Select 32-bit Output Format ELF </H2>

    Option -elf selects output format ELF. JWasm will produce an object module
     in 32-bit Elf format.
<P> 
    Use <A HREF="#OPTELF">OPTION ELF</A> to set values in the ELF header.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTELF64">    Option -elf64: Select 64-bit Output Format ELF </H2>

    Option -elf64 selects output format ELF64. JWasm will produce an object module
    in 64-bit Elf format. Additionally, this option will set cpu to <A HREF="#DIRX64">x86-64</A>
    and model to FLAT.
<P> 
    Use <A HREF="#OPTELF">OPTION ELF</A> to set values in the ELF header.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTEQ">    Option -eq: Suppress Error Messages on Screen </H2>

    Option -eq will suppress displaying error messages on the screen. They are still
    written into an error file.

<H2 ID="CMDOPTFD">    Option -Fd: Write Import Definitions </H2>

    Option -Fd makes JWasm write import definitions in a format understood by
    Open Watcom's Wlink and JWlink. Such definitions will tell the linker
    how to resolve the external reference; no import library is needed. This
    option is only useful in conjunction with <A HREF="#OPTDLLIMPORT">OPTION DLLIMPORT</A> (chapter 3.12).
    Syntax is:
<DL> 
<DD>       -Fd[=file_name]
</DL> 
     If the optional &lt;file_name&gt; argument is given, the import 
     definitions will be written into a file of this name. This is the only
     way for Open Watcom's Wlink to pass the information.
<P>
     If JWlink is used, the &lt;file_name&gt; argument may be omitted. Then
     JWasm will write the import definitions directly into the object module's
     linker directive section (section ".drectve"). This works for output
     formats COFF and ELF only. See sample <A HREF="#AB05">Win32_7</A> how
     to use JWasm and JWlink to create a Windows binary without import libs.

<H2 ID="CMDOPTFPI">    Option -FPi: Activate Floating-Point Emulation </H2>

    Option -FPi activates "inline FP instructions with emulation". This will make JWasm
    create fixups for floating-point instructions if code is 16bit.
    If supported by the linker or the OS, the FP instructions can then
    be replaced by calls to an FP emulator if no coprocessor exists.

<H2 ID="CMDOPTFW">    Option -Fw: Set Error File Name </H2>

    Option -Fw will set the file name for warning and error messages. As default,
    these messages are written to a file with a name equal to the assembly
    source, but with extension .ERR. Syntax is:
<DL> 
<DD>    -Fw file_name
</DL> 
<H2 ID="CMDOPTGCDRZ">    Options -Gc, -Gd, -Gr, -Gz: Set Default Calling Convention </H2>

    The default calling convention set by these options are:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#E8E8E8"><TD>-Gc</TD> <TD>Pascal</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>-Gd</TD> <TD>C(decl)</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>-Gr</TD> <TD><A HREF="#CALLCONVFASTCALL">Fastcall</A></TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>-Gz</TD> <TD>Stdcall</TD> </TR>
</TABLE>

<H2 ID="CMDOPTM">    Option -m: Select Memory Model </H2>

    Option -m generates a line containing a .MODEL directive to
    select a memory model.
    Syntax is:
<DL> 
<DD>    -m[t|s|m|c|l|h|f]
</DL> 
    where the value behind 'm' means:
<DL> 
<DD>    t = tiny
<DD>    s = small
<DD>    m = medium
<DD>    c = compact
<DD>    l = large
<DD>    h = huge
<DD>    f = flat
</DL> 
    This option is ignored if a 64-bit output format (<A HREF="#CMDOPTWIN64">-win64</A> or <A HREF="#CMDOPTELF64">-elf64</A>)
    is active.

<H2 ID="CMDOPTMZ">    Option -mz: Select Output Format MZ </H2>

    Option -mz selects output format MZ. This will write a binary in DOS MZ format. The
    module's default file extension will be changed from .OBJ to .EXE. All
    symbols in the module must resolve internally, no externals are allowed.
    Some values in the "MZ" header can be adjusted by directive <A HREF="#OPTMZ">OPTION MZ</A>
    (see below).
<P>
    As in all binary formats, the listing will contain a binary map; see <A HREF="#OUTPUTFORMATBIN">Binary Output Format</A>
    for more details.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTNC">    Option -nc: Set Code Class Name </H2>

    Option -nc sets the code segment's class name if simplified segment
    directives are used (default:CODE). Syntax is:
<DL> 
<DD>    -nc=name
</DL> 
    where &lt;name&gt; will be the code segment's class name.

<H2 ID="CMDOPTNDNT">    Options -nd and -nt: Set DATA and CODE Segment Names </H2>

    Options -nd and -nt will set the name of the data/code segments
    if simplified segment directives are used. Syntax is:
<DL> 
<DD>      -nt=name_of_code
<DD>      -nd=name_of_data
</DL> 
    The default names are _TEXT for code and _DATA for data.

<H2 ID="CMDOPTNM">    Option -nm: Set Module Name </H2>

    Option -nm sets the module name. Syntax is:
<DL> 
<DD>     -nm=module_name
</DL> 
    The default value for &lt;module_name&gt; is the name of the source file
    without extension.

<H2 ID="CMDOPTPE">    Option -pe: Create a PE Binary </H2>

    Option -pe will make JWasm create a binary in Windows PE format (32- and 64-bit).
    The output module's default file extension will be changed from .OBJ to .EXE. 
<P>
    For more details about the PE format see <A HREF="#OUTPUTFORMATPE">PE Output Format</A>.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTWIN64">    Option -win64: Select Output Format Win64 </H2>

    Option -win64 makes JWasm produce an object module in PE32+ format, 
    the 64-bit format used for Win64 binaries.
<P>
    Option -win64 will also set cpu to <A HREF="#DIRX64">x86-64</A>, model to FLAT and
    default calling convention to <A HREF="#CALLCONVFASTCALL">FASTCALL</A>. This is to make JWasm compatible
    with Masm64 (ML64.EXE).
<P> 
    With <A HREF="#OPTWIN64">OPTION WIN64</A>, parameters specific to Win64 may be set.
<P> 
    For more information about Win64, see <A HREF="#OUTPUTFORMATWIN64">Win64 Output Format</A>.
<P>
    Chapter <A HREF="#CHAPOUTPUTFORMATS">Output Formats</A> lists all available output formats.

<H2 ID="CMDOPTZC">    Option -zc: Set Name Decoration for C </H2>

    This option sets the name decoration for the C ( aka CDECL ) calling convention. There are
    two variants:
<DL> 
<DD>  -zc[m|w]
</DL> 
    -zcm is the default, C names are decorated with an underscore prefix. This is also the way
    Masm does it. The other variant, -zcw, omits the prefix altogether. This is the usual "decoration"
    in Unix/Linux.

<H2 ID="CMDOPTZD">    Option -Zd: Emit Line Number Debugging Info </H2>

    Option -Zd generates line number debug information for OMF and COFF output
    format. For other formats, this option is ignored. Line number
    information allows a debugger to trace the binary on the source code
    level. Debuggers that have been verified to work with this option:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#E8E8E8"><TD>MS CodeView</TD>           <TD>OMF</TD>  <TD>16-bit, Windows and DOS</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>CDB, NTSD</TD>             <TD>COFF</TD> <TD>32- and 64-bit, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>WinDbg</TD>                <TD>COFF</TD> <TD>32- and 64-bit, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS Visual Studio 2008</TD> <TD>COFF</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS Visual Studio 2010</TD> <TD>COFF</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>OW WD/WDW</TD>             <TD>OMF/COFF</TD> <TD>16- and 32-bit, Windows and DOS</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>PellesC IDE</TD>           <TD>COFF</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>Borland TD/TDW/TD32</TD>   <TD>OMF</TD> <TD>16- and 32-bit, Windows and DOS</TD> </TR>
</TABLE>
[1]: the 64-bit version of this software should also be able to debug 64-bit debuggees.

<H2 ID="CMDOPTZF">    Option -zf: Select FASTCALL Type </H2>

    Option -zf selects the FASTCALL calling convention type
    for 16- and 32-bit code. Syntax is:
<DL> 
<DD>    -zf[0|1]
</DL> 
     The default value 0 is MS VC style, while value 1 activates the Open
     Watcom fastcall type.

<H2 ID="CMDOPTZG">    Option -Zg: Masm-compatible Code Generation </H2>

    Option -Zg makes JWasm try an exact copy of Masm's code
     generation, which results in the following changes:
<UL> 
<LI>    the default prologue for procedures will use<br>
        &nbsp;&nbsp;<font color="#008040"><TT>add [e]sp, - localsize</TT></font><br>
        instead of<br>
        &nbsp;&nbsp;<font color="#008040"><TT>sub [e]sp, localsize</TT></font>.
</LI>
<LI>    the default epilogue for procedures will almost always prefer to 
        generate opcode <TT><b>LEAVE</b></TT> if possible.
</LI>
<LI>    expressions<br>
        &nbsp;&nbsp;<font color="#008040"><TT>&lt;reg&gt; == 0</TT></font> and <font color="#008040"><TT>&lt;reg&gt; != 0</TT></font><br>
        will generate code<br>
        &nbsp;&nbsp;<font color="#008040"><TT>or &lt;reg&gt;,&lt;reg&gt;</TT></font><br>
        instead of<br>
        &nbsp;&nbsp;<font color="#008040"><TT>cmp &lt;reg&gt;,0</TT></font>.
</LI>
<LI>    if invoke must extend an argument's size from word to dword,
        register eax remains unchanged.
</LI>
<LI>    the segment value of FAR externals will always be assumed unknown,
        no matter whether the external is defined inside or outside of a 
        segment block. Thus those labels are excluded from "far call
        optimization". 
</LI>
<LI>    <s>if indirect addressing uses 2 (32- or 64-bit) registers <b>and</b> no
        scaling factor is used <b>and</b> the second register isn't ESP/RSP, then
        the registers are swapped: the second becomes base and the first becomes index
        ( the registers in an expression are counted from left to right ).</s>
        [ since v2.10, this is standard behavior ].
</LI>
<LI>    OPATTR will return the language type bits 8-10 for PROCs and PROTOs only.
</LI>
</UL> 

<H2 ID="CMDOPTZI">    Option -Zi: Emit Symbolic Debugging Info </H2>

    Option -Zi generates symbolic debugging info in CodeView V4 style for OMF and
    COFF output format. For other formats, this option is accepted, but
    ignored. Note that -Zi will always enable <A HREF="#CMDOPTZD">-Zd</A> ( line number information ). 
    Debuggers which have been verified to work with this option:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#E8E8E8"><TD>MS CodeView</TD> <TD>16-bit, Windows and DOS</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS CDB or NTSD</TD> <TD>32- and 64-bit, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS WinDbg</TD> <TD>32- and 64-bit, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS Visual Studio 2008</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>MS Visual Studio 2010</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>Open Watcom WD/WDW</TD> <TD>16- and 32-bit, Windows and DOS</TD> </TR>
<TR BGCOLOR="#E8E8E8"><TD>Pelles C IDE</TD> <TD>32-bit<sup>[1]</sup>, Windows</TD> </TR>
</TABLE>
[1]: the 64-bit version of this software should also be able to debug 64-bit debuggees.
<P>
    Usually both the assembler and the linker must be told that symbolic debugging information
    is to be generated ( with MS link, the linker option is /DEBUG ).
<P>
    The -Zi option accepts an <b>optional numeric argument</b> to control the volume of 
    information that is emitted. The values currently accepted are:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#E8E8E8"><TD>0</TD><TD>Just global symbols will be written.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>1</TD><TD>Global &amp; local symbols will be written.
    No user-defined types are included. Usually this reduction does no harm, but may decrease linking time - if lots of modules
    are to be linked, the effect may be quite significant.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>2</TD><TD>This is the default. Global &amp; local symbols and user-defined types are written.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>3</TD><TD>Additionally to 2, symbolic constants (equates) will be written.</TD></TR>
</TABLE>
<P>Also see <A HREF="#OPTCODEVIEW">OPTION CODEVIEW</A> for additional switches to control symbolic debugging output.

<H2 ID="CMDOPTZLOMF">    Options -zlc and -zld: Control Content of OMF Output Module </H2>

    Options -zlc and -zld do reduce size of the OMF output module.
    They might be useful if lots of - small - modules are to be assembled
    and put into a static library. Also, the OMF coment records written
    if -zlc or -zld is NOT set may not be accepted by all linkers.
<P> 
<DL>
<DT>    Option -zlc:</DT>
<DD>    suppresses writing OMF coment records about data in Code segments. 
    These records may help a disassembler to produce nicer listings.
<DT>    Option -zld:</DT>
<DD>    suppresses writing an OMF coment record for each Code segment telling the 
    linker that far calls to targets in the same segments should be optimized. 
    This is more or less a feature for 16-bit code only.
</DL>

<H2 ID="CMDOPTZLCOFF">    Options -zlf, -zlp and -zls: Control Content of COFF Output Module </H2>

    Options -zlf, -zlp and -zls do reduce size of the COFF output module.
    They might be useful if lots of - small - modules are to be assembled
    and put into a static library.
<P> 
<TABLE CELLPADDING="4" CELLSPACING="2">
<TH BGCOLOR="#C8C8C8">Option</TH><TH BGCOLOR="#C8C8C8">Meaning</th>
<TR BGCOLOR="#E8E8E8"><TD>-zlf</TD>
<TD>suppresses the @file entry in the COFF symbol table. This entry is
    usually used for debugging purposes only and hence a - pretty small - amount of space can be saved.
</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-zlp</TD>
<TD>suppresses static (=private) procedures to be included into the COFF
    symbol table - as long as they aren't referenced absolutely. Such procedures
    aren't needed for the linking process. However, since the linker has no knowledge
    of them then, they will also disappear from the linker-generated map-file.<br>
</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-zls</TD>
<TD>suppresses the auxiliary entries for sections in the COFF symbol table.
    These entries may not be needed in all cases and thus a little space
    is saved.
</TD></TR>
</TABLE>

<H2 ID="CMDOPTZM">    Option -Zm: Enable Masm v5 Compatibility </H2>

    Option -Zm (or setting OPTION M510) will do:
<DL>  
<DD>      - set OPTION OLDSTRUCTS
<DD>      - set OPTION DOTNAME
<DD>      - set OPTION SETIF2:TRUE
<DD>      - set OPTION OFFSET:SEGMENT (if no model is set)
<DD>      - set OPTION NOSCOPED (if no model with language specifier is set)
<DD>      - allow to define data items behind code labels
<DD>      - allow "invalid" use of REP/REPE/REPNE instruction prefixes
<DD>      - change precedence of [] and () operator from 1 to 9.
            Hence expression <font color="#008040">-5[bx]</font> is parsed as <font color="#008040">(-5)[bx]</font>, while without -Zm
            it is parsed as <font color="#008040">-(5[bx])</font>, which generates an error.
</DL> 
     Other Masm v5.1 compatibility options aren't implemented yet.

<H2 ID="CMDOPTZNE">    Option -Zne: Disable JWasm Syntax Extensions </H2>

    Option -Zne will disable syntax extensions which aren't supported
    by Masm. Currently these are:
<DL> 
<DD>      - directive <A HREF="#DIRINCBIN">INCBIN</A>
<DD>      - calling convention <A HREF="#CALLCONVFASTCALL">FASTCALL</A>
<DD>      - <A HREF="#BACKQUOTEIDS">IDs enclosed in backquotes</A>
<DD>      - <A HREF="#FPIMMEDIATE">floating-point immediate operands in instructions</A>
<DD>      - directive <A HREF="#OPTFIELDALIGN">OPTION FIELDALIGN</A>
<DD>      - directive <A HREF="#OPTPROCALIGN">OPTION PROCALIGN</A>
<DD>      - directive <A HREF="#OPTMZ">OPTION MZ</A>
<DD>      - directive <A HREF="#OPTELF">OPTION ELF</A>
<DD>      - directive <A HREF="#OPTWIN64">OPTION WIN64</A>
<DD>      - directive <A HREF="#OPTFRAME">OPTION FRAME</A>
<DD>      - directive <A HREF="#OPTRENAMEKEYWORD">OPTION RENAMEKEYWORD</A>
<DD>      - directive <A HREF="#OPTDLLIMPORT">OPTION DLLIMPORT</A>
<DD>      - directive <A HREF="#OPTCODEVIEW">OPTION CODEVIEW</A>
<DD>      - directive <A HREF="#OPTSTACKBASE">OPTION STACKBASE</A>
<DD>      - directives <A HREF="#DIRPUSHCONTEXT">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>
<DD>      - <A HREF="#LABELATTR">attribute LABEL for first macro parameter</A>
<DD>      - <A HREF="#MBRARG">member argument for IF[N]DEF and .ERR[N]DEF directives</A>
<DD>      - <A HREF="#INITMMXMM">integer initializer values for items of type [X]MMWORD</A>
<DD>      - <A HREF="#SIMSEGARG">optional name argument</A> for .DATA, .DATA? and .CONST directives
<DD>      - forward references in arguments for INVOKEd procedures
<DD>      - overrides inside square brackets for base/index registers
<DD>      - <A HREF="#LABELARRAY">Optional Array Size</A> for LABEL Directive</DD>
</DL> 
     Some directives aren't touched by this option, although Masm won't accept them:
<DL>
<DD> <A HREF="#DIRX64">.X64</A> and <A HREF="#DIRX64">.X64p</A>
<DD> <A HREF="#315">INVOKE in 64-bit mode</A>
<DD> runtime conditional directives <b>.IF</b>, <b>.REPEAT</b>, <b>.WHILE</b> in 64-bit mode
</DL>
     If these directives are to be disabled, it must be done with OPTION NOKEYWORD.

<H2 ID="CMDOPTZT">    Option -zt: Set Name Decoration for STDCALL </H2>

    Option -zt will fine-tune name decoration for STDCALL symbols.
    Syntax is:
<DL> 
<DD>  -zt[0|1|2]
</DL> 
    where value 0 will disable name decoration, value 1 will just add
    an underscore prefix and value 2 - which is the default - will emit
    full STDCALL name decoration as expected by most linkers.
<P>
    Option -zt0 will make object modules compatible to ALINK + Win32.lib.
    It may also ease adding assembly modules to Borland's C++Builder or Delphi projects.

<H2 ID="CMDOPTZV8">    Option -Zv8: Enable Masm v8 Procedure Visibility </H2>

    Option -Zv8 changes handling of procedure visibility to the
    way done by Masm v8+. See <A HREF="#OTHERDIFF4">Visibility of Procedures</A>
    for details.

<H2 ID="CMDOPTZZE">    Option -zze: Disable Export Name Decoration </H2>

    Option -zze suppresses name decoration for procedures with
    the EXPORT attribute (exported name only).

<H2 ID="CMDOPTZZS">    Option -zzs: Avoid Wlink COFF Incompatibility </H2>

    Option -zzs is kind of a workaround for a Wlink incompatibility.
    It's useful to be set if 1) the source module has a starting address,
    2) output format is COFF AND 3) Wlink is to be used as linker.


<H1 ID="CHAPSYNTAXEXT">    3. Syntax Extensions </H1>

    This chapter describes the syntax extensions of JWasm compared to
    Masm v8.

<H2 ID="DIRINCBIN">    3.1 Directive INCBIN </H2>
 
    This directive allows to include the contents of a file into
    the object module. Syntax is
<DL style="color:#008040"> 
<DD>    INCBIN filename [, starting offset[, max size]]
</DL> 
    &lt;filename&gt; should be enclosed in &lt;&gt; or double quotes.
<P> 
<P> 
<H2 ID="CALLCONVFASTCALL">    3.2 FASTCALL Register Calling Convention </H2>

    In <b>16- and 32-bit mode</b>, one may use either the Microsoft or the
    Watcom register calling convention. It's selected by option <A HREF="#CMDOPTZF">-zf</A>.
<P> 
    The Microsoft FASTCALL convention uses registers AX, DX and BX in 16-bit
    for the first 3 parameters, and registers ECX and EDX in 32-bit for
    the first 2 parameters which are small enough to fit into a register.
<P> 
    The Open Watcom fastcall convention uses up to four registers ( E/AX,
    E/DX, E/BX, E/CX ). 
<P> 
    In <b>64-bit mode</b>, FASTCALL means the standard Windows 64 ABI if output format is not ELF.
    For <A HREF="#CMDOPTELF64">-elf64</A>, there is no FASTCALL support implemented yet.
<P> 
    To make FASTCALL the default calling convention, there are 3 ways:
<UL>
<LI>    Commandline options <A HREF="#CMDOPTGCDRZ">-Gr</A> ( or <A HREF="#CMDOPTWIN64">-win64</A> )</LI>
<LI>    Second argument of the .MODEL directive: .MODEL FLAT, FASTCALL</LI>
<LI>    Directive OPTION LANGUAGE: FASTCALL</LI>
</UL>

<H2 ID="BACKQUOTEIDS">    3.3 IDs enclosed in Back Quotes </H2>

    IDs can be enclosed in back quotes (`) and thus they can contain
    characters not allowed in "normal" IDs. However, there is at least one case
    where IDs in back quotes won't be recognized: if the expansion operator (%)
    is located at position 0 in a line.
<P>
    Example using back quotes:
<P>
    Module 1:
<pre><font color="#008040">    `functionname.with.dots` PROC C PUBLIC a1:dword</font></pre>
<P>
    Module 2:
<pre><font color="#008040">    `functionname.with.dots` PROTO C :dword
    .code
    INVOKE `functionname.with.dots`, 1</font></pre>
<P> 
    Since IDs in back quotes are not 100% compatible with "normal" IDs, it might
    be considered to use the <b>ALIAS</b> directive instead. Be aware that,
    since the alias handling is a linker task, it is necessary to define both names,
    the alias name and the target name, as public.
<P>

<H2 ID="FPIMMEDIATE">    3.4 Floating-Point Immediates in Instructions </H2>

    Floating-point immediate values are accepted as instruction operands.
    As default, the type is a REAL4, which has a magnitude of 32 bits:
<pre><font color="#008040"> 
        mov eax, 1.0
</font></pre><P>
    With type coercion, it's also possible to define a
    64-bit "double", although it's probably useful in 64-bit code only: 
<pre><font color="#008040"> 
        mov rax, real8 ptr 1.0
</font></pre><P> 
    Additionally, operators LOW32 and HIGH32 accept a floating-point constant
    as argument. In this case, the constant is assumed to have format
    REAL8. Thus it's possible to pass a double constant directly as a
    procedure argument in 32-bit code:
<pre><font color="#008040"> 
       push HIGH32 1.0
       push LOW32 1.0
       call WorkWithReal8Value
</font></pre><P> 
<H2 ID="OPTFIELDALIGN">    3.5 Directive OPTION FIELDALIGN </H2>

    OPTION FIELDALIGN sets the default value for structure alignment. The
    default value is 1 or the value set by cmdline switch -Zp. Syntax is:
<DL style="color:#008040"> 
<DD>      OPTION FIELDALIGN: [1|2|4|8|16|32]
</DL>
    The current default value can be saved/restored with directives
    <A HREF="#DIRPUSHCONTEXT">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>,


<H2 ID="OPTPROCALIGN">    3.6 Directive OPTION PROCALIGN </H2>

    With OPTION PROCALIGN parameter it's possible to automatically
    align procedures. Syntax is:
<DL style="color:#008040"> 
<DD>      OPTION PROCALIGN: [1|2|4|8|16|32]
</DL>
    The default value is 1. The current value can be saved/restored with directives
    <A HREF="#DIRPUSHCONTEXT">PUSHCONTEXT / POPCONTEXT ALIGNMENT</A>,
<P>
    Example:
<P><PRE>
    .386
    .model flat, stdcall
    option PROCALIGN:16
    .code

proc1 PROC
    ret
proc1 endp

proc2 PROC
    ret
proc2 endp

    end
</PRE>

<P>The listing shows that start address of <i>proc2</i> is aligned to 16 (=10h):

<P><PRE>
00000000                        proc1 PROC
00000000                            ret
00000000  C3                *   retn
00000001                        proc1 endp

00000010                        proc2 PROC
00000010                            ret
00000010  C3                *   retn
00000011                        proc2 endp
</PRE>

<P>Note: to ensure that the procedures are aligned in the final binary as 
it is supposed by the OPTION PROCALIGN value, the alignment of the current
code segment must be at least the value of OPTION PROCALIGN.

<H2 ID="OPTMZ">    3.7 Directive OPTION MZ </H2>

    Directive OPTION MZ allows to fine-tune the values written to the
    MZ header if output format MZ (see <A HREF="#CMDOPTMZ">-mz</A> cmdline option) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL style="color:#008040"> 
<DD>      OPTION MZ:[start_fixups][:header_align][:heap_min][:heap_max]
</DL>
    The parameters are:
<P>
<TABLE cellspacing="4">
<TR><TD VALIGN="top"><i>start_fixups</i></TD><TD>offset within the header where segment fixups will start.
      The size of the header will always be at least this value, even if there
      are no fixups at all. Default - and minimum - value is 1Eh.
</TD></TR>
<TR><TD VALIGN="top"><i>header_align</i></TD><TD>alignment of the header (including segment fixups).
      Value must be a power of 2, 10h is the default and minimum.
</TD></TR>
<TR><TD VALIGN="top"><i>heap_min</i></TD><TD>the additional space (in paragraphs) which is needed by
      the binary to run. Default is the total of the sizes of the
      uninitialized BSS and STACK segments.
</TD></TR>
<TR><TD VALIGN="top"><i>heap_max</i></TD><TD>space (in paragraphs) which the binary would like to have.
      Default is FFFFh.
</TD></TR>
</TABLE>
<P> 
<H2 ID="OPTELF">    3.8 Directive OPTION ELF </H2>

    Directive OPTION ELF allows to fine-tune the values written to the
    ELF header if output format ELF (see <A HREF="#CMDOPTELF">-elf</A> or <A HREF="#CMDOPTELF64">-elf64</A>) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL style="color:#008040"> 
<DD>      OPTION ELF:osabi
</DL> 
    The only argument &lt;osabi&gt; will be copied to the ELF header field EI_OSABI.
    It's a numeric constant, and according to the elf specs some valid values are:
<P>
<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E8E8E8"><TD> 0</TD><TD>ELFOSABI_NONE   </TD><TD>unspecified</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 1</TD><TD>ELFOSABI_HPUX   </TD><TD>HP-UX      </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 2</TD><TD>ELFOSABI_NETBSD </TD><TD>NetBSD     </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 3</TD><TD>ELFOSABI_LINUX  </TD><TD>Linux, <b>default</b></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 6</TD><TD>ELFOSABI_SOLARIS</TD><TD>Sun Solaris</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 7</TD><TD>ELFOSABI_AIX    </TD><TD>IBM AIX    </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD> 9</TD><TD>ELFOSABI_FREEBSD</TD><TD>FreeBSD    </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>12</TD><TD>ELFOSABI_OPENBSD</TD><TD>OpenBSD    </TD></TR>
</TABLE>
</TD></TR>
</TABLE>
<P> 
<P> 
<H2 ID="OPTWIN64">    3.9 Directive OPTION WIN64 </H2>

    Directive OPTION WIN64 allows to set parameters for the Win64 output
    format if this format (see <A HREF="#CMDOPTWIN64">-win64</A> cmdline option) is selected. For other output formats,
    this option has no effect. The syntax for the directive is:
<DL style="color:#008040"> 
<DD>      OPTION WIN64: switches
</DL> 
<DL>
<DT>    accepted values for <i>switches</i> are:</DT>
<DD><P>
<DD>     <b>Store Register Arguments</b> [ bit 0 ]:
<DD>     - 0: the "home locations" (also sometimes called
          "shadow space") of the first 4 register  parameters are 
          uninitialized. This is the default setting.
<DD>     - 1: register contents of the PROC's first 4 parameters (RCX, RDX, 
          R8 and R9 ) will be copied to the "home locations" within
          a PROC's prologue.
<DD><P>
<DD>     <b>INVOKE Stack Space Reservation</b> [bit 1]:
<DD>     - 0: for each INVOKE the stack is adjusted to reserve
           space for the parameters required for the call. After the
           call, the space is released again. This is the default setting.
<DD>     - 1: the maximum stack space required by all INVOKEs inside
           a procedure is computed by the assembler and reserved once
           on the procedure's entry. It's released when the procedure is exited.
           If INVOKEs are to be used outside of procedures, the stack space has to be
           reserved manually!<br>
           <b>Note</b>: an assembly time variable, <font color="#008040">@ReservedStack</font>, is created internally
           when this option is set. It will reflect the value computed by the assembler.
           It should also be mentioned that when this option is on, and a procedure contains
           no INVOKEs at all, then nevertheless the minimal amount of 4*8 bytes is
           reserved on the stack.<br>
           <font color="#C00000"><b>Warning</b></font>: You should have understood exactly what this
           option does BEFORE you're using it. Using PUSH/POP instruction pairs to "save" values
           across an INVOKE is <b>VERBOTEN</b> if this option is on.
<DD><P>
<DD>     <b>16-byte Alignment for Local Stack Variables</b> [bit 2]:
<DD>     0: standard 8-byte alignment for local variables.
<DD>     1: 16-byte alignment for local variables. This setting is useful if you 
         want to load or store XMM registers with instructions that expect aligned
         memory references ( i.e. MOVAPS ). Note that variables with size &lt; 16
         are not affected.
</DL> 
<P>
<H2 ID="OPTFRAME">    3.10 Directive OPTION FRAME </H2>

    This option affects 64-bit only. It allows to make JWasm automatically
    generate prologues and epilogues for procedures with the FRAME attribute.
    Thus the code complies to the rules of <A HREF="#WIN64SEH">Win64 SEH</A> (Structured Exception
    Handling). Syntax is
<DL style="color:#008040"> 
<DD>        OPTION FRAME:&lt;AUTO | NOAUTO&gt;
</DL> 
    AUTO will enable this feature, NOAUTO (which is default) disables it.
<P>
    The unwind information which is generated is "complete", that is, it
    contains the ".endprologue" pseudo-op already. To allow to save all
    non-volatile registers in the prologue, the "USES" phrase is more
    capable in this mode and will accept XMM registers to be saved and
    restored.
<P>
<P>
<H2 ID="OPTRENAMEKEYWORD">    3.11 Directive OPTION RENAMEKEYWORD </H2>

    This option allows to rename a keyword, so it can be used under a
    different name. Syntax:
<DL style="color:#008040"> 
<DD>       OPTION RENAMEKEYWORD:&lt;current_name&gt;=new_name
</DL>
     <i>current_name</i> is the current name of the keyword and must be
    enclosed in angle brackets. <i>new_name</i> must be a valid identifier.
     <s>If a keyword is to be renamed, it should be done at the beginning
    of the source, and a keyword shouldn't be renamed multiple times.</s>
    Since v2.11, a keyword may be renamed temporarily and multiple times.
<P> 

<H2 ID="OPTDLLIMPORT">    3.12 Directive OPTION DLLIMPORT </H2>

<H3>    a) Using OPTION DLLIMPORT </H3>

    This option makes the assembler assume that all PROTOs that follow
    this directive represent functions located in a dll. Syntax:
<DL style="color:#008040"> 
<DD>       OPTION DLLIMPORT:&lt;dll_name&gt; | NONE
</DL> 
     &lt;dll_name&gt; must be enclosed in angle brackets. Argument NONE
     will switch back to the default mode.
<P> 

<H3>    b) Code Generation Effects </H3>

    The effects of setting this options are subtle and useful only for 
    MS Windows applications: if the function described by the prototype is
    called via INVOKE, slightly more efficient code than normal is generated,
    because the function's address in the IAT is used. Example:
<DL style="color:#008040"> 
<DD>       INVOKE GetModuleHandle, NULL
</DL> 
    code generation with OPTION DLLIMPORT:
<pre><font color="#008040"> 
        push NULL
        call DWORD PTR [_imp__GetModuleHandle@4]
</font></pre> 
    code generation without OPTION DLLIMPORT:
<pre><font color="#008040"> 
        push NULL
        call _GetModuleHandle@4
        ...
    _GetModuleHandle@4:
        jmp DWORD PTR [_imp__GetModuleHandle@4]  ;stub added by the linker
</font></pre> 

<H3>    c) OPTION DLLIMPORT in Conjunction with -Fd Switch </H3>

    Optionally, by using cmdline option <A HREF="#CMDOPTFD">-Fd</A>, JWasm will write
    the import information received through OPTION DLLIMPORT lines to either
    a file or directly into the object module (COFF and ELF only). Example:
<pre><font color="#008040"> 
        .386
        .model flat,stdcall
        option dllimport:&lt;kernel32&gt;
    GetModuleHandleA proto :dword
    ExitProcess proto :dword
        option dllimport:none
        .code
        invoke GetModuleHandleA, 0
        invoke ExitProcess, 0
        end
</font></pre> 
<DL>
<DD>      JWasm -coff <b>-Fd=lnk.rsp</b> sample.asm
</DL> 
    After the assembly step, file <i>lnk.rsp</i> will contain:
<DL style="color:#008040"> 
<DD>    import '_ExitProcess@4'  kernel32.ExitProcess
<DD>    import '_GetModuleHandleA@4'  kernel32.GetModuleHandleA
</DL>
    Both Open Watcom's Wlink and JWlink will be able to directly use this 
    information and hence, as a result, no further Windows import libraries 
    are needed in the link step:
<DL> 
<DD>      Wlink format windows pe file sample.obj <b>@lnk.rsp</b>
</DL> 
    JWlink may even go one step further - it's able to read import definitions
    contained in a COFF or ELF module's linker directive section ( named
    ".drectve" ). Therefore one can omit the filename argument for -Fd. 
    Sample <A HREF="#AB05">Win32_7</A> demonstrates the usage.
<P> 
<H3>    d) OPTION DLLIMPORT in Conjunction with -pe Switch </H3>

    If output format PE is selected, using OPTION DLLIMPORT is the only way
    to resolve external references; see <A HREF="#OUTPUTFORMATPE">PE Output Format</A> for more information.

<H2 ID="OPTCODEVIEW">    3.13 Directive OPTION CODEVIEW </H2>

    The OPTION CODEVIEW directive allows to fine-tune the generation of symbolic
    debugging information. It has no effect at all if commandline option <A HREF="#CMDOPTZI">-Zi</A> isn't set. Syntax:
<DL style="color:#008040"> 
<DD>       OPTION CODEVIEW:<i>switches</i>
</DL>
<P>    There is currently only one switch :
<P>
<DL>
<DD>     [bit 0]: If 1, create symbols with indices S_[L|G]THREAD32 instead of S_[L|G]DATA32
         for data items that are stored in segments with class 'TLS'. This allows the debugger
         to display the correct value of static TLS ( Thread Local Storage ) variables. Example:
<pre><font color="#008040">
    option codeview:1

_TLS segment dword alias(".tls") public 'TLS'
tvar DD -1      ;codeview symbol tvar will be S_LTHREAD32
_TLS ends
</font></pre>
</DL>
<P> 

<H2 ID="OPTSTACKBASE">    3.13 Directive OPTION STACKBASE </H2>

    The OPTION STACKBASE directive allows to change the way how stack variables -
    defined by the PROC and LOCAL directives - are accessed. Syntax is:
<DL style="color:#008040"> 
<DD>       OPTION STACKBASE:<i>register</i>
</DL>
    <i>register</i> will be the index register that is used for accessing the stack variables.
    The "natural" register for accessing these variables is the [E|R]BP register ( the "frame pointer").
    With OPTION STACKBASE one might set any index register as frame pointer.
<P>
    Besides the goal "frame pointer omission" in 64-bit, OPTION STACKBASE may also be used in 16- and
    32-bit code to make directives PROC and INVOKE handle stack variables correctly when the code and
    stack segment in protected-mode differ in offset magnitude ( 16-bit code running on a 32-bit stack
    and vice versa ).
<P>
    OPTION STACKBASE will additionally define assembly-time variable <b>@StackBase</b>.
    The assembler will add the value of this variable to the effective address of stack variables.
    @StackBase can be modified just like any userdefined variable - however, it is initialized to zero
    by the PROC directive. The purpose for the introduction of @StackBase is to make it
    feasible to use the "volatile" stack-pointer (ESP/RSP) register as base for accessing stack variables.
<P>
    Finally, OPTION STACKBASE will define another assembly-time variable: <b>@ProcStatus</b>.
    This variable is read-only and will allow to query information about the current procedure's status.
    The information that is returned by @ProcStatus is:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<th BGCOLOR="#C8C8C8">Bit</th><th BGCOLOR="#C8C8C8">Meaning if bit is 1</th>
<TR BGCOLOR="#E8E8E8"><TD>0</TD><TD>inside prologue of current procedure.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>1</TD><TD>inside epilogue of current procedure.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>2</TD><TD>"frame-pointer omission" is on for procedure</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>7</TD><TD>prologue of current procedure isn't created yet</TD></TR>
</TABLE>

<H2 ID="DIRPUSHCONTEXT">    3.15 Directives PUSHCONTEXT / POPCONTEXT ALIGNMENT </H2>

    The PUSHCONTEXT / POPCONTEXT directives understand new qualifier
    ALIGNMENT, which saves/restores current values of <A HREF="#OPTFIELDALIGN">FIELDALIGN</A> and
    <A HREF="#OPTPROCALIGN">PROCALIGN</A> options.
<P>
    Note: in JWasm v2.00-2.09, PUSHCONTEXT / POPCONTEXT ALL did include these alignment values. Since
    JWasm v2.10, this is no longer true; this behavior is more Masm-compatible.


<H2 ID="DIRX64">    3.16 Directives .X64 and .X64p </H2>

    These directives select a 64-bit (x86-64) cpu.
    In contrast to .X64, .X64p will allow to use privileged instructions.
<P>
    The .X64 directive isn't needed usually, because for output formats WIN64
    (see <A HREF="#CMDOPTWIN64">-win64</A>) and ELF64 (see <A HREF="#CMDOPTELF64">-elf64</A>),
    .X64 is the default.
<P>
    The .X64p directive is useful for mixed-model binaries or system software (see example <A HREF="#AB03">DOS64</A> ).
<P>
     When the cpu is set to 64-bit, the SEGMENT directive accepts a new
    'size' value: USE64. It tells the assembler that this segment's offset
    is 64-bit wide and uses 64-bit instructions.
<P>
     The SYSCALL calling convention is renamed to SYSCALL_ when 64-bit is on,
    because there exists a SYSCALL instruction mnemonic in this mode.


<H2 ID="LABELATTR">    3.17 Attribute LABEL for first Macro Parameter </H2>

    The LABEL attribute for the first macro parameter allows access to a
    label which is assigned to the macro. Syntax is:
<P>
<font color="#008040">&lt;macro_name&gt; MACRO &lt;param_name&gt;:LABEL [,&lt;param_name&gt;[, ...]]</font>
<P>
    The LABEL attribute is accepted for the first parameter only. A macro
    with such a parameter can be invoked in the following way:
<P>
<font color="#008040">&lt;label&gt; &lt;macro_name&gt; [&lt;argument&gt;, ...]</font>
<P>
    Example:
<pre><font color="#008040"> 
    foo macro lbl:LABEL, first, second
    lbl  db first
         dw second
    endm

    .data

    data1 foo 1,1000
    data2 foo 2,2000
</font></pre>
<P>
    Note that a code label ( that is, a label followed by a colon or double-colon ) is parsed
    BEFORE the macro is evaluated, hence such a label will have been defined already when the
    macro "runs".

<H2 ID="MBRARG">    3.18 Member Argument for IF[N]DEF and .ERR[N]DEF Directives </H2>

    Since v2.07, JWasm's implementation of IF[N]DEF - and .ERR[N]DEF - will
    additionally accept a struct member as argument. This syntax requires
    a fully qualified name:
<P><pre><font color="#008040"> 
      IFDEF &lt;struct_name&gt;.&lt;member_name&gt;
</font></pre><P>

<H2 ID="INITMMXMM">    3.19 Initialization of Data Items with Type MMWORD/XMMWORD </H2>

    For data items of types MMWORD or XMMWORD, JWasm will accept integer
    values for initialization:
<P><pre><font color="#008040"> 
    vmm1  MMWORD  1122334455667788h
    vxmm1 XMMWORD 112233445566778899AABBCCDDEEFFh
</font></pre><P> 
    Masm will accept just floating-point initializers for data items of
    type [X]MMWORD. It's even worse, since floating-point initializers are
    <b>silently</b> ignored for data items with  sizes != 4, 8 and 10; since
    XMMWORD has size 16, it's impossible to initialize such an item directly.
    JWasm copies this Masm behavior, but to allow to initialize a XMMWORD 
    with a floating-point value, one may use type coercion:
<P><pre><font color="#008040"> 
    vxmm1 XMMWORD real4 ptr 1.0   ;bytes 4-15 will be 0
    vxmm2 XMMWORD real8 ptr 1.0   ;bytes 8-15 will be 0
</font></pre><P>
    Variants that work in both JWasm and Masm, and also allow to
    initialize the full XMMWORD are:
<P><pre><font color="#008040"> 
    vxmm1 LABEL XMMWORD
      real4 1.0, 2.0, 3.0, 4.0
    vxmm2 LABEL XMMWORD
      real8 1.0, 2.0
</font></pre><P> 
<P>

<H2 ID="LABELARRAY">    3.20 Optional Array Size for LABEL Directive </H2>

    The LABEL directive accepts an optional array size argument:
<pre><font color="#008040">myarray LABEL word <b>: 10</b> ; myarray is assumed to be an array of 10 words
    dw 1,2,3,4,5,6,7,8,9,10
</font></pre><P>
    Please note that the array size argument defines the array's number of elements,
    not the array's size in bytes. 
<P> This extension allows to define large initialized arrays, not restricted
    by line size limits. The SIZEOF and LENGTHOF operators will return the 
    same values as if the array had been defined via the DUP operator. 
<P> The array size argument may be a forward reference:
<pre><font color="#008040">myarray LABEL word <b>: size_myarray / sizeof word</b>
    dw 1,2,3,4,5,6,7,8,9,10
size_myarray equ $ - myarray
</font></pre><P>

<H2 ID="SIMSEGARG">    3.21 Optional Name Argument for Simplified Segment Directives </H2>

    Masm allows an optional argument for simplified segment directives <b>.CODE</b>,
    <b>.FARDATA</b> and <b>.FARDATA?</b>. This is to set the name of the segment that is to be opened.
    JWasm will also accept the name argument for those directives; additionally, it's
    accepted for <b>.DATA</b>, <b>.DATA?</b> and <b>.CONST</b> directives.

<H2 ID="ATTRCOMDAT">    3.22 Segment Attribute COMDAT </H2>

    With segment attribute COMDAT one may define COMDAT sections. A COMDAT section is a section
    that can be defined by more than one object file. A COMDAT section must contain at least
    one symbol, the <b>COMDAT symbol</b>. The syntax to define the section is:

<P><pre><font color="#008040"> 
    segname SEGMENT <b>COMDAT( selection [, assoc_segment ] )</b> ...
</font></pre><P> 
    The <b>selection</b> argument tells the linker what to do if multiple definitions of a COMDAT symbol are
    found; the accepted values are:

<TABLE CELLPADDING="4" CELLSPACING="2">
<th BGCOLOR="#C8C8C8">Value</th><th BGCOLOR="#C8C8C8"></th><th BGCOLOR="#C8C8C8">Description</th>
<TR BGCOLOR="#E8E8E8"><TD>1</TD><TD>no duplicates</TD><TD>If the symbol is already defined, the linker issues a "multiply defined symbol" error.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>2</TD><TD>any</TD>          <TD>Any section that defines the same COMDAT symbol can be linked; the rest are removed.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>3</TD><TD>same size</TD>    <TD>The linker chooses an arbitrary section among the definitions for this symbol. If all definitions are not the same size, a "multiply defined symbol" error is issued.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>4</TD><TD>exact match</TD>  <TD>The linker chooses an arbitrary section among the definitions for this symbol. If all definitions do not match exactly, a "multiply defined symbol" error is issued.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>5</TD><TD>associative</TD>  <TD>The section is linked if a certain other COMDAT section ( see the <b>assoc_segment</b> in the syntax description ) is linked.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>6</TD><TD>largest</TD>      <TD>The linker chooses the largest definition from among all of the definitions for this symbol. If multiple definitions have this size, the choice between them is arbitrary.</TD></TR>
</TABLE>
<P>
    Currently support for COMDAT is restricted to COFF.
<P>
    JWasm won't do anything special with COMDAT sections; in future releases this may change: cmdline options 
    similar to the Microsoft VC compiler options -Gf or -Gy may be added.
<P>
    To create an object module that places each function in its own COMDAT section ( as it is done by MS VC if the -Gy option
    is given ), it is recommended to use COMDAT in conjunction with ALIAS:

<P><pre><font color="#008040"> 
    _TEXT_proc1 segment flat comdat(1) alias(".text")
    proc1 proc c
        ...
    proc1 endp
    _TEXT1_proc1 ends

    _TEXT_proc2 segment flat comdat(1) alias(".text")
    proc2 proc c private
        ...
    proc2 endp
    _TEXT2_proc2 ends

    _TEXT_proc3 segment flat comdat(1) alias(".text")
    proc3 proc c
        ...
    proc3 endp
    _TEXT_proc3 ends
</font></pre><P> 


<H2 ID="VARARGMLATTR">    3.23 Attribute VARARGML for last Macro Parameter </H2>

    VARARGML has mostly the same effects as attribute VARARG; the difference is that
    VARARGML will make the assembler concat lines if the last character on the line is
    a comma.


<H2 ID="OTHERDIFF">    3.24 Miscellaneous </H2>

<DL>
<DD>   <A HREF="#OTHERDIFF1">    3.24.1 Numeric constant __JWASM__ </A></DD>
<DD>   <A HREF="#OTHERDIFF2">    3.24.2 Operating System Argument for .MODEL </A></DD>
<DD>   <A HREF="#OTHERDIFF3">    3.24.3 Accepted Parameters for IF[N]DEF Directive </A></DD>
<DD>   <A HREF="#OTHERDIFF4">    3.24.4 Visibility of Procedures </A></DD>
<DD>   <A HREF="#OTHERDIFF5">    3.24.5 Non-RIP-Relative Addressing in 64-Bit </A></DD>
</DL>

<H3 ID="OTHERDIFF1">    3.24.1 Numeric constant __JWASM__ </H3>

    __JWASM__ is a predefined symbol, its value is the current JWasm
    version * 100, that is, for v1.9 the value is 190. The predefined text
    equate @Version won't contain JWasm's version, for compatibility reasons
    it has value &lt;800&gt; (since v2.06, previously the value was &lt;615&gt;).

<H3 ID="OTHERDIFF2">    3.24.2 Operating System Argument for .MODEL </H3>

    The .MODEL directive has an optional "operating system" argument. Masm
    accepts value OS_DOS only, JWasm accepts values OS_DOS and OS_OS2.
    This setting will affect the generated code of directives .STARTUP and
    .EXIT for 16-bit memory models.

<H3 ID="OTHERDIFF3">    3.24.3 Accepted Parameters for IF[N]DEF Directive </H3>

    Masm's IF[N]DEF directive accepts user-defined symbols and registers,
    but fails for instructions, directives and other reserved words. JWasm's
    IF[N}DEF implementation accepts those symbols as well. OTOH, JWasm is
    a bit more picky and will display a warning if more than one item is 
    found behind the directive - Masm just takes the first and silently skips
    the rest.
<P>
    Also see <A HREF="#MBGARG">Member Argument for IF[N]DEF and .ERR[N]DEF Directives</A>.

<H3 ID="OTHERDIFF4">    3.24.4 Visibility of Procedures </H3>

    When a PROTO or EXTERNDEF directive for a symbol is located in a module
    before a matching PROC directive, the visibility of this Procedure 
    ( "public" vs "private", or "external" vs. "static" ) is handled 
    differently in Masm v6 or 7 and Masm v8 or newer:
<P> 
    Since Masm v8, a PROTO or EXTERNDEF for a symbol which is later defined
    as a PROC will make the procedure public, no matter what a possible
    visibility attribute of the PROC itself - or the default one set with 
    OPTION PROC - is telling.
<P> 
    OTOH, with Masm v6/7, both the visibility attribute of the PROC directive
    and the current default setting of OPTION PROC will affect the symbol's
    visibility.
<pre>
                Masm6 Masm8 JWasm JWasm+Zv8
      -------------------------------------
      On,E,P            x             x
      On,E,Pn           x             x
      On,E,Pp     x     x      x      x
      Op,E,P      x     x      x      x
      Op,E,Pn     x     x             x
      Op,E,Pp     x     x      x      x

      On = OPTION PROC:PRIVATE
      Op = OPTION PROC:PUBLIC
      E  = PROTO or EXTERNDEF before PROC
      P  = PROC without visibility attribute
      Pn = PROC with PRIVATE visibility attribute
      Pp = PROC with PUBLIC visibility attribute
      x  = procedure will be public
</pre> 
    As default, JWasm more or less copies the Masm v6/7 behavior. The
    difference is that an explicite visibility attribute behind PROC has 
    the highest priority for JWasm. However, since v2.04, there's an 
    additional cmdline option -Zv8 which will make JWasm behave like Masm v8+.
<P> 
    It should be noted that without a PROTO/EXTERNDEF before PROC, there
    are no differences between Masm v6, v8 and JWasm, and the -Zv8 switch
    also has no effect then.
<P> 
<H3 ID="OTHERDIFF5">    3.24.5 Non-RIP-Relative Addressing in 64-Bit </H3>

    In 64-bit a RIP-relative addressing mode was introduced. This mode is used as
	default for direct addressing, because it allows to access all code or data labels
	with a 32-bit displacement. However, for constant address locations this mode
	is not appropriate and won't be used:

<P><pre><font color="#008040"> 
     mov al, gs:[1000h]
     mov al, gs:[100000000h]
</font></pre><P> 

    If a constant address is to be accessed without segment prefixes - note that
    in 64-bit, only segment registers FS and GS can be used as segment prefixes - one has to use
    the FLAT keyword in JWasm:

<P><pre><font color="#008040"> 
     mov al, FLAT:[1000h]           ;invalid for Masm
     mov al, FLAT:[100000000h]      ;invalid for Masm
</font></pre><P> 

   This syntax differs from Masm's, because Masm won't accept FLAT. In 64-bit Masm,
   the syntax for accessing constant addresses is instead:

<P><pre><font color="#008040"> 
     mov al, [1000h]               ;invalid for JWasm
     mov al, [100000000h]          ;invalid for JWasm
</font></pre><P> 
<P> 
  The code that will be generated won't show any differences:
<P><pre>  
0000000000000000: 65 8A 04 25 10 00 00 00              mov al,byte ptr gs:[00000010h]
0000000000000008: 65 A0 00 00 00 00 01 00 00 00        mov al,byte ptr gs:[0000000100000000h]
0000000000000012: 8A 04 25 10 00 00 00                 mov al,byte ptr ds:[00000010h]
0000000000000019: A0 00 00 00 00 01 00 00 00           mov al,byte ptr ds:[0000000100000000h]
</pre><P> 
<P>

<H1 ID="CHAPINSTRSET">    4. Instruction Sets </H1>

    JWasm supports all instructions sets supported by Masm v8. These are
<P>
<DL>
<DD>    - the instructions implemented by 8086, 80186, 80286, 80386, 80486.
<DD>    - the Pentium and Pentium Pro instructions.
<DD>    - the MMX and K3D instruction set extensions.
<DD>    - the SSE, SSE2, SSE3 and SSSE3 instruction set extensions.
<DD>    - the Intel VMX instruction set extension ( since JWasm v2.09 ).
<DD>    - the x86-64 64-bit instruction set ( implemented by ML64 ).
</DL>
    Additionally supported are
<DL>
<DD>    - SSE4.1 and SSE4.2 instruction sets ( since JWasm v2.01 ).
<DD>    - AVX instruction set ( since JWasm v2.06 ).
</DL>
<P>
    With Masm, SSE4.1 and SSE4.2 require Masm v9; AVX requires Masm v10.
<P>
<H1 ID="CHAPCODEGENDIFF">    5. Code Generation Differences </H1>

    JWasm might generate slightly different code than Masm on some occasions.
    Commandline option <A HREF="#CMDOPTZG">-Zg</A> should eliminate most of these differences.
    However, some differences are due to fixed Masm bugs (see below), in
    which case option -Zg won't have any effect.
<P>
    For a few instructions, the encoding differs between Masm versions.
<P> Example:
<PRE><font color="#008040">    cmp al,dl
</font></PRE><P>
    is encoded <TT>38 D0</TT> in Masm v6, but <TT>3A C2</TT> in Masm v8.
    In such cases, JWasm will prefer to copy the encoding of Masm v8. 

<H2 ID="FWDREFINMACRO">    5.1 Forward References in Macro Expressions </H2>

    Like Masm, JWasm usually evaluates expressions in preprocessor directives
    during the first pass only. However, due to different jump optimization
    strategies of Masm and JWasm, the results may differ. This is very
    unlikely to impose a problem, but it is mentioned here for completeness.
    An example (found in README.TXT of Masm v6.14):
<P><pre><font color="#008040"> 
      Label1:
           JMP Label2
      Label2:

      REPEAT Label2 - Label1
           INC AX
      ENDM
</font></pre><P> 
    Masm will - incorrectly - repeat the loop 10 times, although the result
    of expression <TT>Label2 - Label1</TT> is 2 only. OTOH, JWasm will repeat the 
    loop 2 times only, because it's using an "optimistic" strategy concerning
    forward references.
<P> 
<P> 
<H1 ID="CHAPOUTPUTFORMATS">    6. Output Formats </H1>
    The format of the assembler's output is selected by commandline options.
    These are:
<P>
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#OUTPUTFORMATOMF">-omf</A></TD><TD>Intel's "relocatable Object Module Format", including 32-bit MS extensions.<br>
      It's the default.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#OUTPUTFORMATCOFF">-coff</A></TD><TD>(MS) COFF object module format, supports flat memory models only.<br>
      It's usually used for 32-bit Windows modules.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#CMDOPTELF">-elf</A></TD><TD>32-Bit ELF ("Executable and Linkable Format") object modules.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#CMDOPTELF64">-elf64</A></TD><TD>64-bit ELF object modules.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#OUTPUTFORMATWIN64">-win64</A></TD><TD>64-bit format for Win64 object modules. COFF variant with 64-bit extensions.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD><A HREF="#CMDOPTDJGPP">-djgpp</A></TD><TD>COFF variant used by DJGPP.</TD></TR>
<TR BGCOLOR="#D8D8D8"><TD><A HREF="#OUTPUTFORMATBIN">-bin</A></TD><TD>raw binary format.</TD></TR>
<TR BGCOLOR="#D8D8D8"><TD><A HREF="#CMDOPTMZ">-mz</A></TD><TD>DOS MZ binary format.</TD></TR>
<TR BGCOLOR="#D8D8D8"><TD><A HREF="#OUTPUTFORMATPE">-pe</A></TD><TD>32- and 64-bit PE binaries.</TD></TR>
</TABLE>
The formats selected by -bin, -mz and -pe are <b>binary</b> formats, hence the output is not supposed to be fed to a linker.
<P> 

<H2 ID="OUTPUTFORMATOMF">    6.1 OMF Output Format </H2>

   The OMF format fully supports the segmented architecture of the x86 cpu. The specification has been extended
   around 1990 to support 32-bit, including the FLAT memory model. However, since it's a bit old now, there's
   no support of some of the new relocations introduced for 64-bit. 
<UL>
<LI>OMF won't support the IMAGEREL and SECTIONREL operators.</LI>
<LI>JWasm currently won't emit OMF LIDATA records ( unlike Masm). This means that if the assembly source contains
lots of arrays defined with DUP, the object module might become significantly larger than a similiar object module written
by Masm.</LI>
<LI>JWasm emits a few COMENT records that Masm won't. These are remnants of Open Watcom's WASM; they may be suppressed with
commandline options <A HREF="#CMDOPTZLOMF">-zlc</A> and <A HREF="#CMDOPTZLOMF">-zld</A>. They shouldn't do any harm, though.</LI>
</UL>

The OMF object module consists of records of certain types.  JWasm writes those records in the following order:
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR BGCOLOR="#C8C8C8"><TH>Type</TH><TH></TH><TH>Description</TH></TR>
<TR BGCOLOR="#E8E8E8"><TD>THEADR</TD><TD>1</TD><TD>Marks the start of an object module, contains the name of the source file.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class A1h</TD><TD>1</TD><TD>MS extension; tells linker the CodeView version number. Emitted if -Zi option is active.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class E9h</TD><TD>n</TD><TD>Borland-style auto-dependency record(s). Emitted if -Zd or -Zi options are active.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class 9Eh</TD><TD>1</TD><TD>MS extension; directs the linker to use a "standardized" segment ordering. Emitted if the .DOSSEG directive is found in the source.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class 9Fh</TD><TD>n</TD><TD>Default library search name(s). Emitted if INCLUDELIB directives are used.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>LNAMES</TD><TD>n</TD><TD>Defines names for segments and groups ( optionally also for externals, communals and publics ).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>SEGDEF</TD><TD>n</TD><TD>Defines segment(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class FEh</TD><TD>n</TD><TD>Tells WLink to do FARCALL optimization for a specific segment. Suppressed with -zld.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>GRPDEF</TD><TD>n</TD><TD>Defines group(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>EXTDEF</TD><TD>n</TD><TD>Defines external(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class A8h</TD><TD>n</TD><TD>Defines weak external(s). Emitted if EXTERN directive is used with "altname".</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMDEF</TD><TD>n</TD><TD>Defines communal(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>ALIAS</TD><TD>n</TD><TD>Defines alias(es).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>PUBDEF</TD><TD>n</TD><TD>Defines public(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class A0h</TD><TD>n</TD><TD>Defines export(s). Emitted if the EXPORT attribute is used in a PROC directive.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class A2h</TD><TD>1</TD><TD>Link Pass Separator. Emitted if no entry point is defined in this object module.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>LEDATA</TD><TD>n</TD><TD>Data record; defines segment content(s).</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>FIXUPP</TD><TD>n</TD><TD>Contains information to make the linker resolve references between object modules.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>LINNUM</TD><TD>n</TD><TD>Line number information. Emitted if -Zd or -Zi option is active.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>COMENT, class FDh</TD><TD>n</TD><TD>Tells disassembler that a code segment contains data. Suppressed with -zlc.</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>MODEND</TD><TD>1</TD><TD>Marks the end of the object module; optionally defines the entry point.</TD></TR>
</TABLE>
LEDATA, FIXUPP and LINNUM records usually are intermixed; a FIXUPP and/or a LINNUM record appears immediately after
the LEDATA record to which it refers.<br>
Since v2.11, multiple THEADR records are written if cmdline options -Zd or -Zi are set and line number information
is written for more than one source file; this conforms to MASM behavior.
<P> 

<H2 ID="OUTPUTFORMATCOFF">    6.2 COFF Output Format </H2>

    The COFF object module format is suitable for flat, non-segmented memory models. In most cases
	the COFF format is used for 32-bit code. However, it's possible to create a 64-bit COFF module
	if the current cpu is <A HREF="#DIRX64">.x64</A> when the .MODEL directive is parsed 
	( note that <A HREF="#CMDOPTWIN64">-win64</A>
	is the usual way to create modules for 64-bit Windows ). To some extent 16-bit code
	is also supported with COFF, although <A HREF="#OUTPUTFORMATOMF">OMF</A> will always be the
	better choice then.
<P>
<UL>
<LI>The <b>-safeseh</b> cmdline option and the <b>.SAFESEH</b> directive are supported by COFF only.</LI>
<LI>Not supported by COFF are: 
<UL>
  <LI>the <b>GROUP</b> directive</LI>
  <LI>the directives to control segment order: <b>.ALPHA</b>, <b>.DOSSEG</b>, <b>.SEQ</b></LI>
  <LI>code that will generate "far" fixups (i.e. direct FAR calls or jumps ).</LI>
</UL>
</LI>
<LI>A few, common segment names are translated in the output module when COFF is selected:
<UL>
    <LI>name _TEXT is translated to .text</LI>
    <LI>name _DATA is translated to .data</LI>
    <LI>name CONST is translated to .rdata</LI>
    <LI>name _BSS is translated to .bss</LI>
</UL>
   This also affects simplified segment directives, since _TEXT, _DATA, CONST and _BSS segments
   are internally generated when directives .CODE, .DATA, .CONST or .DATA? are detected.
</LI>
<LI>If COFF is selected, Masm will ignore segment combine type STACK and treat stack segments just like normal
    data segments ( the MS linker and compatibles will set the stack's size with commandline options ).
    JWasm DOES NOT ignore combine type STACK for the COFF output format; additionally, unless the segment contains 
    initialized data, <b>JWasm will reset the size of stack segments to 0</b>.
</LI>
<LI>Directive <b>EXTERN name (altname) : &lt;type&gt;</b> will define a weak external with 
    characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY ( see MS PE and COFF specification ).</LI>
<LI>Directive <b>ALIAS &lt;aliasname&gt;=&lt;actual name&gt;</b> will define a weak external with 
    characteristics IMAGE_WEAK_EXTERN_SEARCH_ALIAS ( see MS PE and COFF specification ).</LI>
<LI>There are some cmdline options to control the extent of symbols that are written to the COFF
    output module: <A HREF="#CMDOPTZLCOFF">-zlf</A>, <A HREF="#CMDOPTZLCOFF">-zlp</A> and <A HREF="#CMDOPTZLCOFF">-zls</A>.</LI>
</UL>
<P> 

<H2 ID="OUTPUTFORMATWIN64">    6.3 Win64 Output Format </H2>

<H3>    6.3.1 Win64 Basics </H3>

    This output format, that is selected with the <A HREF="#CMDOPTWIN64">-win64</A> commandline option, is a variant of the
    <A HREF="#OUTPUTFORMATCOFF">COFF output format</A>. It's commonly used to create object modules for 64-bit Windows.
    The default calling convention is the Win64 <A HREF="#CALLCONVFASTCALL">FASTCALL</A> implementation.
<P>

<A NAME="INVOKEW64"></A>
<H3>    6.3.2 Directive INVOKE in Win64 </H3>

    Unlike the 64-bit version of Masm, which doesn't support INVOKE anymore, JWasm still
    does; however, please be aware of some peculiarities:
<UL>
<LI>  in theory, using INVOKE requires the FRAME attribute for PROC. It will
      work without FRAME, but Win64 SEH won't be happy with it then.
</LI>
<LI>  the default implementation in 64-bit is very simple: for each INVOKE register
      RSP is reduced by the space required for the arguments, then the call 
      is issued and finally register RSP is restored. To enable a more efficient code
      generation see <A HREF="#OPTWIN64">OPTION WIN64</A>, <i>INVOKE Stack Space Reservation</i> - this
      option is not active as default because it virtually requires a certain programming style.
</LI>
<LI>  there is no additional check that the stack is aligned to 16 byte. The
      PROC's FRAME attribute ensures that the stack is correctly aligned after
      the prologue is done. However, it's the programmers responsibility that
      the stack is still aligned when the code generated by INVOKE starts.
</LI>
<LI>  parameter names listed behind the PROC directive will always refer to
      the parameter's shadow space on the stack. However, on a procedure's entry
      the actual values of the first four parameters are hold in registers, and
      the value of the associated shadow spaces are undefined. See <A HREF="#OPTWIN64">OPTION WIN64</A>,
      <i>Store Register Arguments</i>, how to make JWasm automatically save the register arguments and thus
      initialize the shadow space on a procedure's entry.
</LI>
</UL>

<A NAME="WIN64SEH"></A>
<H3>    6.3.3 Win64 Structured Exception Handling (SEH) </H3>

    SEH in Win64 differs significantly from the implementation in Win32.
    It's very well possible to ignore Win64 SEH for assembly. However,
    if an assembly routine wants to comply to these rules, a thorough
    understanding of the Win64 ABI is necessary. Masm ( the 64-bit
    version ) supplies some "primitives" for SEH support (.ALLOCSTACK,
    .PUSHREG, .SAVEREG, ...), along with a new FRAME attribute for the
    PROC directive. These features are also supported by JWasm. See sample
    <A HREF="#AB01">Win64_3</A> how the "primitives" are to be used for SEH support.
<P>
    The big disadvantage is that using the FRAME keyword in Masm "disables"
    most of the other high level features combined with PROC (function 
    parameters, locals and registers saved with USES) because no function
    prologues and epilogues are generated anymore. Additionally, the 
    implementation at least in Masm v8 seems to be a bit buggy, at least in Masm v8.
    Because of this and to ease the usage of SEH in Win64 there is a new 
    directive implemented in JWasm:
<PRE><font color="#008040"> 
        <A HREF="#OPTFRAME">OPTION FRAME:AUTO</A>
</font></PRE><P> 
    If this option is set, JWasm will create Win64 SEH-compatible prologues
    and epilogues. If the option is off, JWasm will behave Masm-compatible,
    that is, FRAME found in a PROC directive will disable automatic 
    prologue/epilogue generation. See sample <A HREF="#AB02">Win64_3e</A> how this option
    is supposed to be used.
<P> 
    As for the PROC syntax: The Masm documentation states that FRAME can be
    used in combination with USES and procedure parameters and must be
    located behind all parameters. However, this syntax isn't accepted by
    any Masm version. The only syntax which Masm will accept without being
    confused is FRAME as the one and only parameter for PROC. Therefore
    JWasm doesn't follow the Masm documentation in this point: the optional
    FRAME keyword is expected *before* the procedure parameters. The syntax
    in JWasm is:
<P><pre><font color="#008040"> 
    procname PROC [public] FRAME[:exc_handler] [USES &lt;reglist&gt;] [parameters]
</font></pre><P> 
    The SEH "primitives" will generate some additional data in segments
    .pdata and .xdata. This data is somewhat hidden, but JWasm will display
    the corresponding data definitions in the listing if option -Sg is set.
<P>
    Finally, JWasm's default behavior of INVOKE isn't fully SEH-compatible, because the
    stack pointer is temporarily changed to make room for arguments. To make
    INVOKE comply to SEH, <A HREF="#OPTWIN64">OPTION WIN64</A>
    <i>INVOKE Stack Space Reservation</i> has to be used.
<P> 

<H2 ID="OUTPUTFORMATBIN">    6.4 Binary Output Format </H2>

    If the binary output format has been selected, the contents of the file
    are just the raw data bytes emitted by the assembler, no header,
    relocations or symbol tables are generated. All references have to be
    resolved internally.
<P>
    The binary format is most useful for bootloaders or DOS COM files, but may
    be used to create any binary format. See sample <A HREF="#AB04">Win32_5</A>,
    that demonstrates how the binary format is used to create a Win32 application.
<P>
    If a listing file is produced, a binary map will be added, which shows 
    the file and memory layout of the image:
<PRE> 
                                    .model tiny

                                    .data

00000000  0D0A48656C6C6F2C20    str1    db 13,10,"Hello, world!",13,10,'$'

00000000                            .code

                                    org 100h

00000100                        start:

00000100  B409                      mov ah, 09h
00000102  BA0000                    mov dx, offset str1
00000105  CD21                      int 21h
00000107  B8004C                    mov ax, 4c00h
0000010A  CD21                      int 21h

                                    end start


Binary Map:

Segment                  Pos(file)      VA  Size(fil) Size(mem)
---------------------------------------------------------------
_TEXT                           0      100         C         C
_DATA                           C      10C        12        12
---------------------------------------------------------------
                                                  1E        1E
</PRE>
<P>
    Note that bytes with "undefined contents" at the start and the end of the output file
    are skipped and won't become part of the binary.
<P>

<H2 ID="OUTPUTFORMATPE">    6.5 PE Output Format </H2>

    The ( Windows ) PE output format ( both 32- and 64-bit ) is a binary format - 
    there's no link step supposed to follow the assembly step. Hence all references
    must be resolved internally, no external references are possible. Since the Windows
    ABI is implemented as a set of dlls that export function names, it's necessary 
    to provide a mechanism to call such external functions - in the PE format this
    is achieved with the help of directive <A HREF="#OPTDLLIMPORT">OPTION DLLIMPORT</A>; 
    it allows to attach a module name to function prototypes used by the assembly source
    and consequently give the assembler the means to resolve all references without the help of a linker.
<P>
    The PE format requires a .MODEL FLAT directive in the source code. This directive
    will trigger the creation of the internal PE-header section, the value of
    the cpu at this time will determine whether a 32- or 64-bit PE binary is to be written.
<P>
    As in all binary formats, the listing will contain a binary map; see <A HREF="#OUTPUTFORMATBIN">Binary Output Format</A>
    for more details.
<P>
    If -pe is set, a few sections will be created internally: 
<DL>
<DD>   -.hdr$1 : section will contain the DOS MZ-stub.
<DD>   -.hdr$2 : section will contain the PE header
<DD>   -.hdr$3 : section will contain the PE object table
</DL>
<P>
    The default values in the PE header are
<TABLE CELLPADDING="4" CELLSPACING="2">
<TR><TH>Field</TH><TH>32-bit Value</TH><TH>64-bit Value (if different)</TH></TR>
<TR BGCOLOR="#E8E8E8"><TD>Signature</TD> <TD>"PE"</TD> <TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Machine</TD>   <TD>14Ch</TD> <TD>8664h</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Timestamp</TD> <TD>date &amp; time</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Size OptionalHeader</TD> <TD>0E0h</TD><TD>0F0h</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Characteristics</TD> <TD>10Fh</TD><TD>12Fh</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Magic</TD>     <TD>10Bh</TD><TD>20Bh</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>LinkerVersion</TD><TD>5.1</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>ImageBase</TD><TD>exe: 400000h<br>dll: 10000000h</TD><TD>140000000h<br>180000000h</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>SectionAlignment</TD><TD>1000h</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>FileAlignment</TD><TD>200h</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>OSVersion</TD><TD>4.0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>ImageVersion</TD><TD>0.0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>SubsystemVersion</TD><TD>4.0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Win32Version</TD><TD>0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Checksum</TD><TD>0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>Subsystem</TD><TD>3 (=Console)</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>DllCharacteristics</TD><TD>0</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>SizeOfStack</TD><TD>100000h,1000h</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>SizeOfHeap</TD><TD>100000h,1000h</TD><TD></TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>LoaderFlags</TD><TD>0</TD><TD></TD></TR>
</TABLE>
<P>
    To change the default values in the PE header there are two options. First, a
    predefined assembly-time variable <b>@pe_file_flags</b> will map the value
    of field <i>Characteristics</i> - changing the value of @pe_file_flags will also change the value
    in the header field. The other fields in the PE header are only accessible
    by setting the appropriate values in section .hdr$2. Fields not listed in the table
    above are set internally by the assembler to ensure data integrity and cannot be modified
    from within the assembly source.
<P>
    If the PE binary is to use <b>resources</b>, a .rsrc section has to be created which is to
    contain them. Defining the resources manually works and is doable, but it might become tedious
    if a lot of resource items are to be defined. Therefore tool <b>res2inc</b> is supplied, which
    allows to convert a compiled resource file (.RES) to an assembly include file.
<P>
    If a <b>dll</b> is created with -pe, one has to mark all procedures that are to be exported with
    the EXPORT attribute. If the exported names are to be undecorated, use the 
    <A HREF="#CMDOPTZZE">-zze</A> cmdline option.
<P>
    Sample <A HREF="#AB06">Win64_8</A> shows how a 64-bit Windows binary is created with -pe. It also
    shows how to define resources in .rsrc manually and how to modify default values of PE header fields.


<H1 ID="CHAPMASMBUGS">    7. Masm bugs fixed in JWasm </H1>

<TABLE CELLPADDING="4" CELLSPACING="2">

<TR BGCOLOR="#C8C8C8"><TH>#</TH><TH>Description</TH><TH>Fixed Masm Version</TH></TR>
<TR BGCOLOR="#E8E8E8"><TD>1</TD><TD>the infamous "invoke" bug: if an argument for invoke has to be expanded
       (from BYTE or WORD to DWORD, for example ), bad code was generated.
</TD><TD>9</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>2</TD><TD>PROTOs contained twice in the source caused an EXTDEF entry to be
      generated in the object module.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>3</TD><TD>"TYPE xmm0" will return 10 in Masm v6 and v7 - the correct value is 16.
</TD><TD>8</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>4</TD><TD>a nested structure might cause a GPF in Masm if the embedded STRUCT's
      starting offset has to be adjusted due to alignment.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>5</TD><TD>defining huge arrays in Masm is very slow and might even cause a
      deadlock if COFF has been selected as output format.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>6</TD><TD>for Masm v6 and v7, if an array > 64 kB is defined and output
      format OMF is selected, the array's size will be mod 0x10000 only.
</TD><TD>8</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>7</TD><TD>Masm doesn't flag invalid numbers in struct/array initializer strings.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>8</TD><TD>if an ALIAS is defined somewhere in the source and the symbol table
      is listed, a 'General Failure' error occurs in Masm if output format
      is OMF.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>9</TD><TD>Type "coerces" for DWORD data items defined in a 32bit segment are
      ignored by Masm, i.e., "dd far16 ptr &lt;symbol&gt;" will generate a
      near32 fixup instead of a far16 one.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>10</TD><TD>if the ALIGN directive has to add 5 bytes in 32bit code segments,
      Masm includes an "add eax,0" opcode, which isn't a no-op because
      flags are modified.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>11</TD><TD>silent truncation of immediate constants: Masm v6 and v7 will accept
      line "mov [word_variable],12345h" without error.
</TD><TD>8</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>12</TD><TD>preprocessed output with option -EP may erroneously contain text
      macros and macro function calls if the macros are located in the
      initialization string of a structured variable.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>13</TD><TD>Masm generates wrong code if a conditional jump is coupled with a
      type coercion which modifies offset magnitude. Examples: "jz near32
      ptr ..." in 16bit code or "jz near16 ptr ..." in 32bit code).
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>14</TD><TD>if the arguments given to Masm end with an option which expects
      a parameter (i.e. "ml -c -Fo"), a 'General Failure' may occur.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>15</TD><TD>floating-point data items in Masm can be followed by any suffix
      (example: REAL4 1.0foo, 2.0bar). JWasm won't accept this.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>16</TD><TD>If a local is defined inside a macro, Masm will create a unique name
      for it. The name is constructed by using '??' as prefix, followed by
      a hexadecimal number with 4 digits. There is no check for overflow,
      however, so if the total of locals in all macros exceeds 65536,
      strange errors will occur.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>17</TD><TD>If a weak external is defined for -coff with the ALIAS directive,
      an invalid fixup - and also a strange entry in the module's symbol table - is created.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>18</TD><TD>If a section contains more than 0xffff relocations in COFF,
      the number of relocations that is stored in the object module is just the value of the lower 16-bit half of
      the relocation count.
</TD><TD>8</TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>19</TD><TD>If a symbolic constant (=equate) is made public in OMF format, 
      Masm will store the symbol's value in a 16-bit record if it is in the range -32768 ... 65535. If the
      symbol is referenced in another module as a 32-bit number, it is always zero-extended, never
      sign-extended; hence values -1 ... -32768 will become 65535 ... 32768.
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>20</TD><TD>if data labels become public by the -Zf option ( and not by the PUBLIC
      directive ), their names are not decorated. Also, if format is COFF, they won't become true publics,
      they're just included in the symbol table with class "static".
</TD><TD>-</TD></TR>
<TR BGCOLOR="#E0E0E0"><TD>21</TD><TD>in 16-bit code, Masm will accept opcode "mov ax,es:[10000h]" although
      offset 10000h exceeds 16-bit ( it will be truncated to 16-bit ). JWasm emits a level 3 warning and
      the offset is NOT truncated.
</TD><TD>-</TD></TR>
</TABLE>

    It's slightly dangerous to fix old Masm bugs, since some code might
    work only if the bugs exists. So no, JWasm won't achieve 100% Masm
    compatibility.
<P> 
<P> 
<H1 ID="CHAPOPTFEAT">    8. Optional Features </H1>

  There exist some features that are not activated in the
  precompiled binaries. To enable these options, the JWasm source must be
  recompiled with one or more switches set in the command line:

<H2>    Support for Assembly Source generated by Intel C++ compiler</H2>
  This option is enabled with switch <b>-DDOTNAMEX</b>. It will make the
  assembler accept names that contain dots if the name starts with a dot
  or an underscore. Note that this behavior is not compatible with standard
  Masm syntax.
<P> 
<P> 
<H1 ID="CHAPKNOWNBUGS">    9. Known Bugs and missing Features </H1>

<H2>    a) Bugs which are known but not fixed yet: </H2>

    There are currently no known bugs.

<H2>    b) Features which aren't implemented yet: </H2>
<DL> 
<DD>    - directives PAGE, TITLE, SUBTITLE, SUBTTL.
      the directives are ignored and a warning (level 4) is displayed.
<DD>    - the following parameters of the OPTION directive:
<DL>
<DD>      - OLDMACROS
<DD>      - EXPR16
<DD>      - READONLY
</DL>
<DD>    - optional parameter NONUNIQUE for structures is ignored.
<DD>    - commandline option -AT (Enable tiny model).
<DD>    - commandline options -Sp, -Ss and -St (set page length, subtitle and title).
<DD>    - commandline option -H (set max external name length).
<DD>    - commandline option -Ta (Assemble non-.ASM file).
<DD>    - commandline option -Zd for ELF output format.
<DD>    - commandline option -Zi for ELF output format.
</DL> 
<P>
    If there's ever a problem with one of the missing features, it's very likely
    that it's related to OPTION OLDMACROS. This option makes Masm 6 emulate two
    Masm 5.1 peculiarities:
<DL>
<DD>    - macro arguments may be separated by spaces
<DD>    - ampersands (&amp;) inside the macro must match the current level of
          macro nesting.
</DL>
<H2>    c) Missing features which most likely won't be implemented: </H2>
<DL> 
<DD>    - syntax "mm(n)" and "xmm(n)" (supported by Masm v6 and v7 only)
<DD>    - commandline option -Bl, -F, -Fe, -Fm and -link: since JWasm doesn't launch a linker, those
          options are useless.
<DD>    - commandline options -Fr and -FR (generate browser info).
<DD>    - commandline option -Sc (generate timings in listing).
<DD>    - commandline option -errorReport (Report internal assembler errors to Microsoft).
</DL> 

<H1 ID="CHAPLICENSE">    10. License </H1>

<P> This manual was written by Andreas Grech ( aka Japheth ).
<P> It may be redistributed as long as it is free of charge.

<H1 ID="AA"> Appendix A. JWasm Reserved Words </H1>

Reserved Words are case-insensitive. Besides the items listed below all
instruction mnemonics are also Reserved Words.

<H2>Registers 16- and 32-bit Modes</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#F0F0F0">
<TD>8-bit registers</TD>
<TD>AL</TD>
<TD>CL</TD>
<TD>DL</TD>  
<TD>BL</TD>  
<TD>AH</TD>  
<TD>CH</TD>  
<TD>DH</TD>  
<TD>BH</TD>  
</TR>
<TR BGCOLOR="#ECECEC">
<TD>16-bit registers</TD>
<TD>AX</TD>    
<TD>CX</TD>    
<TD>DX</TD>    
<TD>BX</TD>    
<TD>SP</TD>    
<TD>BP</TD>    
<TD>SI</TD>    
<TD>DI</TD>    
</TR>
<TR BGCOLOR="#E8E8E8">
<TD>32-bit registers</TD>
<TD>EAX</TD>    
<TD>ECX</TD> 
<TD>EDX</TD> 
<TD>EBX</TD> 
<TD>ESP</TD> 
<TD>EBP</TD> 
<TD>ESI</TD> 
<TD>EDI</TD> 
</TR>
<TR BGCOLOR="#F0F0E8">
<TD>Segment registers</TD>
<TD>ES  </TD> 
<TD>CS  </TD> 
<TD>SS  </TD> 
<TD>DS  </TD> 
<TD>FS  </TD> 
<TD>GS  </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
<TR BGCOLOR="#F0E8F0">
<TD>Floating-point registers</TD>
<TD>ST  </TD> 
<TD>ST(1)</TD> 
<TD>ST(2)</TD> 
<TD>ST(3)</TD> 
<TD>ST(4)</TD> 
<TD>ST(5)</TD> 
<TD>ST(6)</TD> 
<TD>ST(7)</TD> 
</TR>
<TR BGCOLOR="#E8F0F0">
<TD>MMX registers</TD>
<TD>MM0 </TD> 
<TD>MM1 </TD> 
<TD>MM2 </TD> 
<TD>MM3 </TD> 
<TD>MM4 </TD> 
<TD>MM5 </TD> 
<TD>MM6 </TD> 
<TD>MM7 </TD> 
</TR>
<TR BGCOLOR="#E0F0F0">
<TD>SSE registers</TD>
<TD>XMM0 </TD> 
<TD>XMM1 </TD> 
<TD>XMM2 </TD> 
<TD>XMM3 </TD> 
<TD>XMM4 </TD> 
<TD>XMM5 </TD> 
<TD>XMM6 </TD> 
<TD>XMM7 </TD> 
</TR>
<TR BGCOLOR="#D8F0F0">
<TD>AVX registers</TD>
<TD>YMM0 </TD> 
<TD>YMM1 </TD> 
<TD>YMM2 </TD> 
<TD>YMM3 </TD> 
<TD>YMM4 </TD> 
<TD>YMM5 </TD> 
<TD>YMM6 </TD> 
<TD>YMM7 </TD> 
</TR>
<TR BGCOLOR="#F0E0E0">
<TD>Control registers</TD>
<TD>CR0 </TD> 
<TD> </TD> 
<TD>CR2 </TD> 
<TD>CR3 </TD> 
<TD>CR4 </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
<TR BGCOLOR="#F0F0E0">
<TD>Debug registers</TD>
<TD>DR0 </TD> 
<TD>DR1 </TD> 
<TD>DR2 </TD> 
<TD>DR3 </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>DR6 </TD> 
<TD>DR7 </TD> 
</TR>
<TR BGCOLOR="#E0E0F0">
<TD>Test registers<sup>[1]</sup></TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>TR3 </TD> 
<TD>TR4 </TD> 
<TD>TR5 </TD> 
<TD>TR6 </TD> 
<TD>TR7 </TD>
</TR>
</TABLE>
</TD></TR>
</TABLE>
[1]: invalid in 64-bit mode.

<H2>Additional Registers in 64-bit Mode</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#F0F0F0">
<TD>8-bit registers</TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD>SPL </TD> 
<TD>BPL </TD> 
<TD>SIL </TD> 
<TD>DIL </TD> 
</TR>
<TR BGCOLOR="#F0F0F0">
<TD></TD>
<TD>R8B </TD> 
<TD>R9B </TD> 
<TD>R10B</TD> 
<TD>R11B</TD> 
<TD>R12B</TD> 
<TD>R13B</TD> 
<TD>R14B</TD> 
<TD>R15B</TD>
</TR>
<TR BGCOLOR="#ECECEC">
<TD>16-bit registers</TD>
<TD>R8W  </TD> 
<TD>R9W  </TD> 
<TD>R10W </TD> 
<TD>R11W </TD> 
<TD>R12W </TD> 
<TD>R13W </TD> 
<TD>R14W </TD> 
<TD>R15W </TD> 
</TR>
<TR BGCOLOR="#E8E8E8">
<TD>32-bit registers</TD>
<TD>R8D  </TD> 
<TD>R9D  </TD> 
<TD>R10D </TD> 
<TD>R11D </TD> 
<TD>R12D </TD> 
<TD>R13D </TD> 
<TD>R14D </TD> 
<TD>R15D </TD> 
</TR>
<TR BGCOLOR="#E4E4E4">
<TD>64-bit registers</TD>
<TD>RAX  </TD> 
<TD>RCX  </TD> 
<TD>RDX  </TD> 
<TD>RBX  </TD> 
<TD>RSP  </TD> 
<TD>RBP  </TD> 
<TD>RSI  </TD> 
<TD>RDI  </TD> 
</TR>
<TR BGCOLOR="#E4E4E4">
<TD></TD>
<TD>R8   </TD> 
<TD>R9   </TD> 
<TD>R10  </TD> 
<TD>R11  </TD> 
<TD>R12  </TD> 
<TD>R13  </TD> 
<TD>R14  </TD> 
<TD>R15  </TD> 
</TR>
<TR BGCOLOR="#E0F0F0">
<TD>SSE registers</TD>
<TD>XMM8     </TD> 
<TD>XMM9     </TD> 
<TD>XMM10    </TD> 
<TD>XMM11    </TD> 
<TD>XMM12    </TD> 
<TD>XMM13    </TD> 
<TD>XMM14    </TD> 
<TD>XMM15    </TD> 
</TR>
<TR BGCOLOR="#D8F0F0">
<TD>AVX registers</TD>
<TD>YMM8     </TD> 
<TD>YMM9     </TD> 
<TD>YMM10    </TD> 
<TD>YMM11    </TD> 
<TD>YMM12    </TD> 
<TD>YMM13    </TD> 
<TD>YMM14    </TD> 
<TD>YMM15    </TD> 
</TR>
<TR BGCOLOR="#F0E0E0">
<TD>Control registers</TD>
<TD>CR8</TD>
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
<TD> </TD> 
</TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Types</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8D8DC"><TD>BYTE   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SBYTE  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>WORD   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>DWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SDWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL4  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>QWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>SQWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL8  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>TBYTE  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>REAL10 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>OWORD  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>YMMWORD</TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR   </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR    </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR16 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>NEAR32 </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR16  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>FAR32  </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>MMWORD </TD></TR>
<TR BGCOLOR="#D8D8DC"><TD>XMMWORD</TD></TR>
</TABLE>
</TD></TR>
</TABLE>

<H2>Unary Operators</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8DCDC"><TD>.TYPE      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGH       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGH32     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>HIGHWORD   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>IMAGEREL<sup>[1]</sup></TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LENGTH     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LENGTHOF   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOW        </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOW32      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LOWWORD    </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>LROFFSET   </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>MASK       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>OFFSET     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>OPATTR     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SECTIONREL<sup>[1]</sup></TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SEG        </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SHORT      </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SIZE       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>SIZEOF     </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>THIS       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>TYPE       </TD></TR>
<TR BGCOLOR="#D8DCDC"><TD>WIDTH      </TD></TR>
</TABLE>
</TD></TR>
</TABLE>
[1]: not for OMF output format.

<H2>Binary Operators</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#DCDCD8"><TD>EQ  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>NE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>GE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>GT  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>LE  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>LT  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>MOD </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>PTR </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>DUP </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>SHL<sup>[1]</sup> </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>SHR<sup>[1]</sup> </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>AND<sup>[1]</sup> </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>OR<sup>[1]</sup>  </TD></TR>
<TR BGCOLOR="#DCDCD8"><TD>XOR<sup>[1]</sup> </TD></TR>
</TABLE>
</TD></TR>
</TABLE>
[1]: these keywords are also instructions.

<H2>Directives</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8F0D8"><TD>.8086  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.186   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286C  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.286P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386C  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.386P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.486   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.486P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.586   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.586P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.686   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.686P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.K3D   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.MMX   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.XMM   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.X64   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.X64P  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.8087  </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.287   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.387   </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.NO87  </TD></TR> 

<TR BGCOLOR="#D0E8D8"><TD>.CREF        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LIST        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTALL     </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTIF, .LFCOND</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOCREF, .XCREF</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLIST, .XLIST</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLISTIF, .SFCOND</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.TFCOND      </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>PAGE         </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>SUBTITLE, SUBTTL</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>TITLE        </TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTMACRO, .XALL</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.LISTMACROALL, .LALL</TD></TR> 
<TR BGCOLOR="#D0E8D8"><TD>.NOLISTMACRO, .SALL</TD></TR> 

<TR BGCOLOR="#D4F0D4"><TD>.ALPHA       </TD></TR> 
<TR BGCOLOR="#D4F0D4"><TD>.DOSSEG, DOSSEG</TD></TR> 
<TR BGCOLOR="#D4F0D4"><TD>.SEQ         </TD></TR> 

<TR BGCOLOR="#D4F4D8"><TD>.CODE        </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.STACK       </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.DATA        </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.DATA?       </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.FARDATA     </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.FARDATA?    </TD></TR> 
<TR BGCOLOR="#D4F4D8"><TD>.CONST       </TD></TR> 

<TR BGCOLOR="#D8F0D0"><TD>.IF          </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.REPEAT      </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.WHILE       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.BREAK       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.CONTINUE    </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ELSE        </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ELSEIF      </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ENDIF       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.ENDW        </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.UNTIL       </TD></TR> 
<TR BGCOLOR="#D8F0D0"><TD>.UNTILCXZ    </TD></TR> 

<TR BGCOLOR="#D0F0D8"><TD>.EXIT        </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.STARTUP     </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.MODEL       </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.RADIX       </TD></TR> 
<TR BGCOLOR="#D0F0D8"><TD>.SAFESEH     </TD></TR> 

<TR BGCOLOR="#D8F0D8"><TD>.ERR         </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERR1        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERR2        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRE        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNZ       </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDIF      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDIFI     </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRIDN      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRIDNI     </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRB        </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNB       </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRDEF      </TD></TR> 
<TR BGCOLOR="#D8F0D8"><TD>.ERRNDEF     </TD></TR> 

<TR BGCOLOR="#D8F8D8"><TD>COMMENT      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF           </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFE          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF1          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IF2          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDIF        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDIFI       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFIDN        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFIDNI       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFB          </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFNB         </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFDEF        </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>IFNDEF       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSE         </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF       </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFE      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF1      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIF2      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDIF    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDIFI   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFIDN    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFIDNI   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFB      </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFNB     </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFDEF    </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ELSEIFNDEF   </TD></TR> 
<TR BGCOLOR="#D8F8D8"><TD>ENDIF        </TD></TR> 

<TR BGCOLOR="#C8F0D8"><TD>FOR, IRP     </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>FORC, IRPC   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>REPEAT, REPT </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>WHILE        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>MACRO        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>EXITM        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ENDM         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>GOTO         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>PURGE        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCLUDE      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>TEXTEQU      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>CATSTR       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>SUBSTR       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INSTR        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>SIZESTR      </TD></TR> 

<TR BGCOLOR="#D8F0C8"><TD>DB           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DW           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DD           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DF           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DQ           </TD></TR> 
<TR BGCOLOR="#D8F0C8"><TD>DT           </TD></TR> 

<TR BGCOLOR="#D8F0DC"><TD>STRUCT, STRUC</TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>UNION        </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>TYPEDEF      </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>RECORD       </TD></TR> 

<TR BGCOLOR="#D8E8D8"><TD>COMM         </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>EXTERN, EXTRN</TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>EXTERNDEF    </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>PUBLIC       </TD></TR> 
<TR BGCOLOR="#D8E8D8"><TD>PROTO        </TD></TR> 

<TR BGCOLOR="#D4F0D8"><TD>PROC         </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>ENDP         </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>LOCAL        </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>LABEL        </TD></TR> 
<TR BGCOLOR="#D4F0D8"><TD>INVOKE       </TD></TR> 

<TR BGCOLOR="#D8F0DC"><TD>ORG          </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>ALIGN        </TD></TR> 
<TR BGCOLOR="#D8F0DC"><TD>EVEN         </TD></TR> 

<TR BGCOLOR="#C8F0D8"><TD>SEGMENT      </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ENDS         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>GROUP        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ASSUME       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ALIAS        </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>ECHO, %OUT   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>END          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>EQU          </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCBIN       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>INCLUDELIB   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>NAME         </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>OPTION       </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>POPCONTEXT   </TD></TR> 
<TR BGCOLOR="#C8F0D8"><TD>PUSHCONTEXT  </TD></TR> 
</TABLE>
</TD></TR>
</TABLE>

<H2>Additional Directives in 64-bit Mode</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#D8E0D8"><TD>.ALLOCSTACK  </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.ENDPROLOG   </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.PUSHFRAME   </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.PUSHREG     </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SAVEREG     </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SAVEXMM128  </TD></TR> 
<TR BGCOLOR="#D8E0D8"><TD>.SETFRAME    </TD></TR> 
</TABLE>
</TD></TR>
</TABLE>

<H2>Other Reserved Words</H2>

<TABLE CELLSPACING="1">
<TR><TD>
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#ECECD8"><TD>ADDR   </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>FLAT   </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>VARARG </TD></TR>
<TR BGCOLOR="#ECECD8"><TD>FRAME<sup>[1]</sup>  </TD></TR>
<TR BGCOLOR="#ECE8D0"><TD>C       </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>SYSCALL<sup>[2]</sup> </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>STDCALL </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>PASCAL  </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>FORTRAN </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>BASIC   </TD></TR> 
<TR BGCOLOR="#ECE8D0"><TD>FASTCALL</TD></TR> 
</TABLE>
</TD></TR>
</TABLE>
[1]: in 64-bit mode only.<br>
[2]: in 64-bit, calling convention SYSCALL is renamed to SYSCALL_, since
in this mode there exists a SYSCALL instruction.<br>



<H1 ID="AB"> Appendix B. Source Samples </H1>

<DL>
<DD>   <A HREF="#AB01">Win64_3 - SEH Support in Win64</A></DD>
<DD>   <A HREF="#AB02">Win64_3e - SEH Support in Win64 (JWasm specific)</A></DD>
<DD>   <A HREF="#AB03">DOS64 - Switch to Long Mode and Back</A></DD>
<DD>   <A HREF="#AB04">Win32_5 - Create a Win32 Binary with -bin</A></DD>
<DD>   <A HREF="#AB05">Win32_7 - Usage of OPTION DLLIMPORT and -Fd Switch</A></DD>
<DD>   <A HREF="#AB06">Win64_8 - Create a Win64 Binary with -pe</A></DD>
</DL>

<H2 ID="AB01"> Win64_3 - SEH Support in Win64 </H2>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- This sample shows how to use SEH primitives. It doesn't use hll</font>
;<font color="#808080">--- directives. Thus this source can be assembled by both JWasm </font>
;<font color="#808080">--- and Masm64.</font>
;<font color="#808080">---</font>
;<font color="#808080">--- to assemble enter:</font>
;<font color="#808080">---   JWasm -win64 Win64_3.asm</font>
;<font color="#808080">--- or:</font>
;<font color="#808080">---   ml64 -c Win64_3.asm</font>
;<font color="#808080">---</font>
;<font color="#808080">--- to link the binary enter:</font>
;<font color="#808080">---   Link Win64_3.obj</font>

    <b>option</b> casemap:none

    <b>includelib</b> kernel32.lib
    <b>includelib</b> user32.lib

HINSTANCE <b>typedef</b> QWORD
HWND      <b>typedef</b> QWORD
HMENU     <b>typedef</b> QWORD
HICON     <b>typedef</b> QWORD
HBRUSH    <b>typedef</b> QWORD
HCURSOR   <b>typedef</b> QWORD
WPARAM    <b>typedef</b> QWORD
LPARAM    <b>typedef</b> QWORD
LPSTR     <b>typedef</b> QWORD
LPVOID    <b>typedef</b> QWORD
UINT      <b>typedef</b> DWORD

NULL           <b>equ</b> 0
WS_OVERLAPPEDWINDOW <b>equ</b> 0CF0000h
CW_USEDEFAULT  <b>equ</b> 80000000h
SW_SHOWDEFAULT <b>equ</b> 10
SW_SHOWNORMAL  <b>equ</b> 1
IDC_ARROW      <b>equ</b> 32512
IDI_APPLICATION <b>equ</b> 32512
WM_DESTROY     <b>equ</b> 2
CS_VREDRAW     <b>equ</b> 1
CS_HREDRAW     <b>equ</b> 2
COLOR_WINDOW   <b>equ</b> 5

proto_WNDPROC <b>typedef</b> proto :HWND,:QWORD,:WPARAM,:LPARAM
WNDPROC <b>typedef</b> ptr proto_WNDPROC

WNDCLASSEXA <b>struct</b> 8
cbSize          DWORD   ?
style           DWORD   ?
lpfnWndProc     WNDPROC ?
cbClsExtra      DWORD   ?
cbWndExtra      DWORD   ?
hInstance       HINSTANCE ?
hIcon           HICON   ?
hCursor         HCURSOR ?
hbrBackground   HBRUSH  ?
lpszMenuName    LPSTR   ?
lpszClassName   LPSTR   ?
hIconSm         HICON   ?
WNDCLASSEXA <b>ends</b>

POINT   <b>struct</b>
x   SDWORD  ?
y   SDWORD  ?
POINT   <b>ends</b>

MSG <b>struct</b> 8
hwnd    HWND    ?
message DWORD   ?
wParam  WPARAM  ?
lParam  LPARAM  ?
time    DWORD   ?
pt      POINT   &lt;&gt;
MSG <b>ends</b>

GetModuleHandleA <b>proto</b> :LPSTR
GetCommandLineA  <b>proto</b>
ExitProcess      <b>proto</b> :UINT
LoadIconA        <b>proto</b> :HINSTANCE, :LPSTR
LoadCursorA      <b>proto</b> :HINSTANCE, :LPSTR
RegisterClassExA <b>proto</b> :ptr WNDCLASSEXA
CreateWindowExA  <b>proto</b> :DWORD, :LPSTR, :LPSTR, :DWORD, :SDWORD, :SDWORD, :SDWORD, :SDWORD, :HWND, :HMENU, :HINSTANCE, :LPVOID
ShowWindow       <b>proto</b> :HWND, :SDWORD
UpdateWindow     <b>proto</b> :HWND
GetMessageA      <b>proto</b> :ptr MSG, :HWND, :SDWORD, :SDWORD
TranslateMessage <b>proto</b> :ptr MSG
DispatchMessageA <b>proto</b> :ptr MSG
PostQuitMessage  <b>proto</b> :SDWORD
DefWindowProcA   <b>proto</b> :HWND, :UINT, :WPARAM, :LPARAM

;<font color="#808080">WinMain proto :HINSTANCE, :HINSTANCE, :LPSTR, :UINT</font>

    <b>.data</b>

ClassName <b>db</b> "SimpleWinClass",0
AppName  <b>db</b> "Our First Window",0

    <b>.data?</b>

hInstance HINSTANCE ?
CommandLine LPSTR ?

    <b>.code</b>

WinMainCRTStartup <b>proc</b> FRAME
    <font color="#0000E0">push</font>   rbp
    <b>.pushreg</b> rbp
    <font color="#0000E0">mov</font>    rbp,rsp
    <b>.setframe</b> rbp, 0
    <b>.endprolog</b>

    <font color="#0000E0">sub</font>    rsp,32
    <font color="#0000E0">mov</font>    ecx,NULL
    <font color="#0000E0">call</font>   GetModuleHandleA
    <font color="#0000E0">mov</font>    hInstance, rax
    <font color="#0000E0">call</font>   GetCommandLineA
    <font color="#0000E0">mov</font>    CommandLine, rax
    <font color="#0000E0">mov</font>    rcx, hInstance
    <font color="#0000E0">mov</font>    rdx, NULL
    <font color="#0000E0">mov</font>    r8, CommandLine
    <font color="#0000E0">mov</font>    r9d, SW_SHOWDEFAULT
    <font color="#0000E0">call</font>   WinMain
    <font color="#0000E0">mov</font>    ecx, eax
    <font color="#0000E0">call</font>   ExitProcess
    <b>align</b> 4
WinMainCRTStartup <b>endp</b>

WinMain <b>proc</b> FRAME

    <font color="#0000E0">push</font>  rbp
    <b>.pushreg</b> rbp
    <font color="#0000E0">mov</font>   rbp,rsp
    <b>.setframe</b> rbp, 0
    <b>.endprolog</b>
    <font color="#0000E0">sub</font>   rsp, sizeof WNDCLASSEXA + sizeof MSG + sizeof HWND + 12*8

hInst     <b>equ</b> &lt;[rbp+10h]&gt;
hPrevInst <b>equ</b> &lt;[rbp+18h]&gt;
CmdLine   <b>equ</b> &lt;[rbp+20h]&gt;
CmdShow   <b>equ</b> &lt;[rbp+28h]&gt;

wc   <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA].WNDCLASSEXA&gt;
msg  <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA - sizeof MSG].MSG&gt;
hwnd <b>equ</b> &lt;[rbp - sizeof WNDCLASSEXA - sizeof MSG - sizeof HWND]&gt;

    <font color="#0000E0">mov</font>   hInst, rcx  ;<font color="#808080">store param1 in shadow space</font>

    <font color="#0000E0">mov</font>   wc.cbSize, SIZEOF WNDCLASSEXA
    <font color="#0000E0">mov</font>   wc.style, CS_HREDRAW <font color="#0000E0">or</font> CS_VREDRAW
;<font color="#808080">   mov   rax, OFFSET WndProc  ;using LEA is preferable</font>
    <font color="#0000E0">lea</font>   rax, [WndProc]
    <font color="#0000E0">mov</font>   wc.lpfnWndProc, rax
    <font color="#0000E0">mov</font>   wc.cbClsExtra, NULL
    <font color="#0000E0">mov</font>   wc.cbWndExtra, NULL
    <font color="#0000E0">mov</font>   wc.hInstance, rcx
    <font color="#0000E0">mov</font>   wc.hbrBackground, COLOR_WINDOW+1
    <font color="#0000E0">mov</font>   wc.lpszMenuName, NULL
;<font color="#808080">    mov   rax, OFFSET ClassName  ;using LEA is preferable</font>
    <font color="#0000E0">lea</font>   rax, [ClassName]
    <font color="#0000E0">mov</font>   wc.lpszClassName, rax
    <font color="#0000E0">mov</font>   ecx, NULL
    <font color="#0000E0">mov</font>   edx, IDI_APPLICATION
    <font color="#0000E0">call</font>  LoadIconA
    <font color="#0000E0">mov</font>   wc.hIcon, rax
    <font color="#0000E0">mov</font>   wc.hIconSm, rax
    <font color="#0000E0">mov</font>   ecx, NULL
    <font color="#0000E0">mov</font>   edx, IDC_ARROW
    <font color="#0000E0">call</font>  LoadCursorA
    <font color="#0000E0">mov</font>   wc.hCursor,rax
    <font color="#0000E0">lea</font>   rcx, wc
    <font color="#0000E0">call</font>  RegisterClassExA
    <font color="#0000E0">mov</font>   ecx, NULL
    <font color="#0000E0">lea</font>   rdx, [ClassName]
    <font color="#0000E0">lea</font>   r8, [AppName]
    <font color="#0000E0">mov</font>   r9d, WS_OVERLAPPEDWINDOW
    <font color="#0000E0">mov</font>   dword ptr [rsp+4*8], CW_USEDEFAULT
    <font color="#0000E0">mov</font>   dword ptr [rsp+5*8], CW_USEDEFAULT
    <font color="#0000E0">mov</font>   dword ptr [rsp+6*8], CW_USEDEFAULT
    <font color="#0000E0">mov</font>   dword ptr [rsp+7*8], CW_USEDEFAULT
    <font color="#0000E0">mov</font>   qword ptr [rsp+8*8], NULL
    <font color="#0000E0">mov</font>   qword ptr [rsp+9*8], NULL
    <font color="#0000E0">mov</font>   rax, hInst
    <font color="#0000E0">mov</font>   [rsp+10*8], rax
    <font color="#0000E0">mov</font>   qword ptr [rsp+11*8], NULL
    <font color="#0000E0">call</font>  CreateWindowExA
    <font color="#0000E0">mov</font>   hwnd,rax
    <font color="#0000E0">mov</font>   rcx, hwnd
    <font color="#0000E0">mov</font>   edx, SW_SHOWNORMAL
    <font color="#0000E0">call</font>  ShowWindow
    <font color="#0000E0">mov</font>   rcx, hwnd
    <font color="#0000E0">call</font>  UpdateWindow
;<font color="#808080">--- message loop</font>
@@:
        <font color="#0000E0">lea</font> rcx, msg
        <font color="#0000E0">mov</font> rdx, NULL
        <font color="#0000E0">mov</font> r8, 0
        <font color="#0000E0">mov</font> r9, 0
        <font color="#0000E0">call</font> GetMessageA
        <font color="#0000E0">and</font> rax, rax
        <font color="#0000E0">jz</font> @F
        <font color="#0000E0">lea</font> rcx, msg
        <font color="#0000E0">call</font> TranslateMessage
        <font color="#0000E0">lea</font> rcx, msg
        <font color="#0000E0">call</font> DispatchMessageA
        jmp @B
@@:
    <font color="#0000E0">mov</font>   rax, msg.wParam
    <font color="#0000E0">add</font>   rsp, sizeof WNDCLASSEXA + sizeof MSG + sizeof HWND + 12*8
    <font color="#0000E0">pop</font>   rbp
    <font color="#0000E0">ret</font>
    <b>align</b> 4
WinMain <b>endp</b>

WndProc <b>proc</b> FRAME

    <font color="#0000E0">sub</font>   rsp, 4*8
    <b>.allocstack</b> 4*8
    <b>.endprolog</b>

    <font color="#0000E0">cmp</font> edx, WM_DESTROY
    <font color="#0000E0">jnz</font> @F
    <font color="#0000E0">mov</font> ecx, NULL
    <font color="#0000E0">call</font> PostQuitMessage
    <font color="#0000E0">xor</font> rax,rax
    jmp exit
@@:
    <font color="#0000E0">call</font> DefWindowProcA
exit:
    <font color="#0000E0">add</font> rsp, 4*8
    <font color="#0000E0">ret</font>
    <b>align</b> 4
WndProc <b>endp</b>

<b>end</b>
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB02"> Win64_3e - SEH Support in Win64 (JWasm specific) </H2>

<TABLE BORDER=0 CELLSPACING="4" CELLPADDING="4">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- SEH support in Win64. Unlike Win64_3, </font>
;<font color="#808080">--- this version uses hll directives, so it cannot be assembled</font>
;<font color="#808080">--- with Masm64. Also, OPTION FRAME:AUTO is used.</font>
;<font color="#808080">---</font>
;<font color="#808080">--- to create the binary enter:</font>
;<font color="#808080">---   JWasm -win64 Win64_3e.asm</font>
;<font color="#808080">---   Link Win64_3e.obj</font>

    <b>option</b> casemap:none
    <b>option</b> frame:auto    ;<font color="#808080">generate SEH-compatible prologues and epilogues</font>

    <b>includelib</b> kernel32.lib
    <b>includelib</b> user32.lib

HINSTANCE <b>typedef</b> QWORD
HWND      <b>typedef</b> QWORD
HMENU     <b>typedef</b> QWORD
HICON     <b>typedef</b> QWORD
HBRUSH    <b>typedef</b> QWORD
HCURSOR   <b>typedef</b> QWORD
WPARAM    <b>typedef</b> QWORD
LPARAM    <b>typedef</b> QWORD
LPSTR     <b>typedef</b> QWORD
LPVOID    <b>typedef</b> QWORD
UINT      <b>typedef</b> DWORD

NULL           <b>equ</b> 0
WS_OVERLAPPEDWINDOW <b>equ</b> 0CF0000h
CW_USEDEFAULT  <b>equ</b> 80000000h
SW_SHOWDEFAULT <b>equ</b> 10
SW_SHOWNORMAL  <b>equ</b> 1
IDC_ARROW      <b>equ</b> 32512
IDI_APPLICATION <b>equ</b> 32512
WM_DESTROY     <b>equ</b> 2
CS_VREDRAW     <b>equ</b> 1
CS_HREDRAW     <b>equ</b> 2
COLOR_WINDOW   <b>equ</b> 5

proto_WNDPROC <b>typedef</b> proto :HWND,:QWORD,:WPARAM,:LPARAM
WNDPROC <b>typedef</b> ptr proto_WNDPROC

WNDCLASSEXA <b>struct</b> 8
cbSize          DWORD   ?
style           DWORD   ?
lpfnWndProc     WNDPROC ?
cbClsExtra      DWORD   ?
cbWndExtra      DWORD   ?
hInstance       HINSTANCE ?
hIcon           HICON   ?
hCursor         HCURSOR ?
hbrBackground   HBRUSH  ?
lpszMenuName    LPSTR   ?
lpszClassName   LPSTR   ?
hIconSm         HICON   ?
WNDCLASSEXA <b>ends</b>

POINT   <b>struct</b>
x   SDWORD  ?
y   SDWORD  ?
POINT   <b>ends</b>

MSG <b>struct</b> 8
hwnd    HWND    ?
message DWORD   ?
wParam  WPARAM  ?
lParam  LPARAM  ?
time    DWORD   ?
pt      POINT   &lt;&gt;
MSG <b>ends</b>

GetModuleHandleA <b>proto</b> :LPSTR
GetCommandLineA  <b>proto</b>
ExitProcess      <b>proto</b> :UINT
LoadIconA        <b>proto</b> :HINSTANCE, :LPSTR
LoadCursorA      <b>proto</b> :HINSTANCE, :LPSTR
RegisterClassExA <b>proto</b> :ptr WNDCLASSEXA
CreateWindowExA  <b>proto</b> :DWORD, :LPSTR, :LPSTR, :DWORD, :SDWORD, :SDWORD, :SDWORD, :SDWORD, :HWND, :HMENU, :HINSTANCE, :LPVOID
ShowWindow       <b>proto</b> :HWND, :SDWORD
UpdateWindow     <b>proto</b> :HWND
GetMessageA      <b>proto</b> :ptr MSG, :HWND, :SDWORD, :SDWORD
TranslateMessage <b>proto</b> :ptr MSG
DispatchMessageA <b>proto</b> :ptr MSG
PostQuitMessage  <b>proto</b> :SDWORD
DefWindowProcA   <b>proto</b> :HWND, :UINT, :WPARAM, :LPARAM

WinMain <b>proto</b> :HINSTANCE, :HINSTANCE, :LPSTR, :UINT

    <b>.data</b>

ClassName <b>db</b> "SimpleWinClass",0
AppName  <b>db</b> "Our First Window",0

    <b>.data?</b>

hInstance HINSTANCE ?
CommandLine LPSTR ?

    <b>.code</b>

WinMainCRTStartup <b>proc</b> FRAME

    <b>invoke</b> GetModuleHandleA, NULL
    <font color="#0000E0">mov</font>    hInstance, rax
    <b>invoke</b> GetCommandLineA
    <font color="#0000E0">mov</font>    CommandLine, rax
    <b>invoke</b> WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT
    <b>invoke</b> ExitProcess, eax

WinMainCRTStartup <b>endp</b>

WinMain <b>proc</b> FRAME hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:UINT

    <b>local</b> wc:WNDCLASSEXA
    <b>local</b> msg:MSG
    <b>local</b> hwnd:HWND

    <font color="#0000E0">mov</font>   hInst, rcx
    <font color="#0000E0">mov</font>   wc.cbSize, SIZEOF WNDCLASSEXA
    <font color="#0000E0">mov</font>   wc.style, CS_HREDRAW <font color="#0000E0">or</font> CS_VREDRAW
    <font color="#0000E0">lea</font>   rax, [WndProc]
    <font color="#0000E0">mov</font>   wc.lpfnWndProc, rax
    <font color="#0000E0">mov</font>   wc.cbClsExtra, NULL
    <font color="#0000E0">mov</font>   wc.cbWndExtra, NULL
    <font color="#0000E0">mov</font>   wc.hInstance, rcx
    <font color="#0000E0">mov</font>   wc.hbrBackground, COLOR_WINDOW+1
    <font color="#0000E0">mov</font>   wc.lpszMenuName, NULL
    <font color="#0000E0">lea</font>   rax, [ClassName]
    <font color="#0000E0">mov</font>   wc.lpszClassName, rax
    <b>invoke</b> LoadIconA, NULL, IDI_APPLICATION
    <font color="#0000E0">mov</font>   wc.hIcon, rax
    <font color="#0000E0">mov</font>   wc.hIconSm, rax
    <b>invoke</b> LoadCursorA, NULL, IDC_ARROW
    <font color="#0000E0">mov</font>   wc.hCursor,rax
    <b>invoke</b> RegisterClassExA, addr wc
    <b>invoke</b> CreateWindowExA, NULL, ADDR ClassName, ADDR AppName,\
           WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,\
           CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT, NULL, NULL,\
           hInst, NULL
    <font color="#0000E0">mov</font>   hwnd,rax
    <b>invoke</b> ShowWindow, hwnd, SW_SHOWNORMAL
    <b>invoke</b> UpdateWindow, hwnd
    <b>.while</b> (1)
        <b>invoke</b> GetMessageA, ADDR msg, NULL, 0, 0
        <b>.break</b> .if (!rax)
        <b>invoke</b> TranslateMessage, ADDR msg
        <b>invoke</b> DispatchMessageA, ADDR msg
    <b>.endw</b>
    <font color="#0000E0">mov</font>   rax, msg.wParam
    <font color="#0000E0">ret</font>
WinMain <b>endp</b>

WndProc <b>proc</b> FRAME hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM

    <b>.if</b> ( edx == WM_DESTROY )
        <b>invoke</b> PostQuitMessage, NULL
        <font color="#0000E0">xor</font> rax,rax
    <b>.else</b>
        <b>invoke</b> DefWindowProcA, rcx, edx, r8, r9
    <b>.endif</b>
    <font color="#0000E0">ret</font>
WndProc <b>endp</b>

<b>end</b> WinMainCRTStartup
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB03"> DOS64 - Switch to Long Mode and Back </H2>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- DOS program which switches to long-mode and back.</font>
;<font color="#808080">--- Note: requires at least JWasm v2.</font>
;<font color="#808080">--- Also: needs a 64bit cpu in real-mode to run.</font>
;<font color="#808080">--- Parts of the source are based on samples supplied by</font>
;<font color="#808080">--- sinsi and Tomasz Grysztar in the FASM forum.</font>
;<font color="#808080">--- To create the binary enter:</font>
;<font color="#808080">---  JWasm -mz DOS64.asm</font>

    <b>.x64p</b>

;<font color="#808080">--- 16bit start/exit code</font>

_TEXT16 <b>segment</b> use16 para public 'CODE'

    <b>assume</b> <font color="#00B000">ds</font>:_TEXT16
    <b>assume</b> <font color="#00B000">es</font>:_TEXT16

GDTR <b>label</b> <font color="#800000">fword</font>        ;<font color="#808080"> Global Descriptors Table Register</font>
    <b>dw</b> 4*8-1            ;<font color="#808080"> limit of GDT (size minus one)</font>
    <b>dd</b> <font color="#808000">offset</font> GDT       ;<font color="#808080"> linear address of GDT</font>
IDTR <b>label</b> <font color="#800000">fword</font>        ;<font color="#808080"> Interrupt Descriptor Table Register</font>
    <b>dw</b> 256*16-1         ;<font color="#808080"> limit of IDT (size minus one)</font>
    <b>dd</b> 0                ;<font color="#808080"> linear address of IDT</font>
nullidt <b>label</b> <font color="#800000">fword</font>
    <b>dw</b> 3FFh
    <b>dd</b> 0
  
    <b>align</b> 8
GDT <b>dq</b> 0                    ;<font color="#808080"> null descriptor</font>
    <b>dw</b> 0FFFFh,0,9A00h,0AFh  ;<font color="#808080"> 64-bit code descriptor</font>
    <b>dw</b> 0FFFFh,0,9A00h,000h  ;<font color="#808080"> compatibility mode code descriptor</font>
    <b>dw</b> 0FFFFh,0,9200h,000h  ;<font color="#808080"> compatibility mode data descriptor</font>

wPICMask <b>dw</b> 0   ;<font color="#808080"> variable to save/restore PIC masks</font>

start16:
    <font color="#0000E0">push</font> <font color="#00B000">cs</font>
    <font color="#0000E0">pop</font> <font color="#00B000">ds</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,<font color="#00B000">cs</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">eax</font>,<font color="#00B000">ax</font>
    <font color="#0000E0">shl</font> <font color="#00B000">eax</font>,4
    <font color="#0000E0">add</font> <font color="#800000">dword</font> <font color="#808000">ptr</font> [GDTR+2], <font color="#00B000">eax</font> ;<font color="#808080"> convert offset to linear address</font>
    <font color="#0000E0">mov</font> <font color="#800000">word</font> <font color="#808000">ptr</font> [GDT+2*8+2], <font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#800000">word</font> <font color="#808000">ptr</font> [GDT+3*8+2], <font color="#00B000">ax</font>
    <font color="#0000E0">shr</font> <font color="#00B000">eax</font>,16
    <font color="#0000E0">mov</font> <font color="#800000">byte</font> <font color="#808000">ptr</font> [GDT+2*8+4], <font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#800000">byte</font> <font color="#808000">ptr</font> [GDT+3*8+4], <font color="#00B000">al</font>

    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,<font color="#00B000">ss</font>
    <font color="#0000E0">mov</font> <font color="#00B000">dx</font>,<font color="#00B000">es</font>
    <font color="#0000E0">sub</font> <font color="#00B000">ax</font>,<font color="#00B000">dx</font>
    <font color="#0000E0">mov</font> <font color="#00B000">bx</font>,<font color="#00B000">sp</font>
    <font color="#0000E0">shr</font> <font color="#00B000">bx</font>,4
    <font color="#0000E0">add</font> <font color="#00B000">bx</font>,<font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,4Ah
    <font color="#0000E0">int</font> 21h         ;<font color="#808080"> free unused memory</font>
    <font color="#0000E0">push</font> <font color="#00B000">cs</font>
    <font color="#0000E0">pop</font> <font color="#00B000">es</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,<font color="#00B000">ss</font>
    <font color="#0000E0">mov</font> <font color="#00B000">dx</font>,<font color="#00B000">cs</font>
    <font color="#0000E0">sub</font> <font color="#00B000">ax</font>,<font color="#00B000">dx</font>
    <font color="#0000E0">shl</font> <font color="#00B000">ax</font>,4
    <font color="#0000E0">add</font> <font color="#00B000">ax</font>,<font color="#00B000">sp</font>
    <font color="#0000E0">push</font> <font color="#00B000">ds</font>
    <font color="#0000E0">pop</font> <font color="#00B000">ss</font>
    <font color="#0000E0">mov</font> <font color="#00B000">sp</font>,<font color="#00B000">ax</font>       ;<font color="#808080"> make a TINY model, CS=SS=DS=ES</font>

    <font color="#0000E0">smsw</font> <font color="#00B000">ax</font>
    <font color="#0000E0">test</font> <font color="#00B000">al</font>,1
    <font color="#0000E0">jz</font> @F
    <font color="#0000E0">mov</font> <font color="#00B000">dx</font>,<font color="#808000">offset</font> err1
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,9
    <font color="#0000E0">int</font> 21h
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,4Ch
    <font color="#0000E0">int</font> 21h
err1 <b>db</b> "Mode is V86. Need REAL mode to switch to LONG mode!",13,10,'$'
@@:
    <font color="#0000E0">xor</font> <font color="#00B000">edx</font>,<font color="#00B000">edx</font>
    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,80000001h   ;<font color="#808080"> test if long-mode is supported</font>
    <font color="#0000E0">cpuid</font>
    <font color="#0000E0">test</font> <font color="#00B000">edx</font>,20000000h
    <font color="#0000E0">jnz</font> @F
    <font color="#0000E0">mov</font> <font color="#00B000">dx</font>,<font color="#808000">offset</font> err2
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,9
    <font color="#0000E0">int</font> 21h
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,4Ch
    <font color="#0000E0">int</font> 21h
err2 <b>db</b> "No 64bit cpu detected.",13,10,'$'
@@:
    <font color="#0000E0">mov</font> <font color="#00B000">bx</font>,1000h
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,48h
    <font color="#0000E0">int</font> 21h
    <font color="#0000E0">jnc</font> @F
    <font color="#0000E0">mov</font> <font color="#00B000">dx</font>,<font color="#808000">offset</font> err3
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,9
    <font color="#0000E0">int</font> 21h
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,4Ch
    <font color="#0000E0">int</font> 21h
err3 <b>db</b> "Out of memory",13,10,'$'
@@:
    <font color="#0000E0">add</font> <font color="#00B000">ax</font>,100h-1   ;<font color="#808080"> align to page boundary</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,0
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>,<font color="#00B000">ax</font>

;<font color="#808080">--- setup page directories and tables</font>

    <font color="#0000E0">sub</font> <font color="#00B000">di</font>,<font color="#00B000">di</font>
    <font color="#0000E0">mov</font> <font color="#00B000">cx</font>,4096
    <font color="#0000E0">sub</font> <font color="#00B000">eax</font>,<font color="#00B000">eax</font>
    <font color="#0000E0">rep</font> <font color="#0000E0">stosd</font>       ;<font color="#808080"> clear 4 pages</font>

    <font color="#0000E0">sub</font> <font color="#00B000">di</font>,<font color="#00B000">di</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,<font color="#00B000">es</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">eax</font>,<font color="#00B000">ax</font>
    <font color="#0000E0">shl</font> <font color="#00B000">eax</font>,4
    <font color="#0000E0">mov</font> <font color="#00B000">cr3</font>,<font color="#00B000">eax</font>             ;<font color="#808080"> load page-map level-4 base</font>

    <font color="#0000E0">lea</font> <font color="#00B000">edx</font>, [<font color="#00B000">eax</font>+5000h]
    <font color="#0000E0">mov</font> <font color="#800000">dword</font> <font color="#808000">ptr</font> [IDTR+2], <font color="#00B000">edx</font>

    <font color="#0000E0">or</font> <font color="#00B000">eax</font>,111b
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, 1000h
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+0000h],<font color="#00B000">eax</font>   ;<font color="#808080"> first PDP table</font>
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, 1000h
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+1000h],<font color="#00B000">eax</font>   ;<font color="#808080"> first page directory</font>
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, 1000h
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+2000h],<font color="#00B000">eax</font>   ;<font color="#808080"> first page table</font>
    <font color="#0000E0">mov</font> <font color="#00B000">di</font>,3000h            ;<font color="#808080"> address of first page table</font>
    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,0 + 111b
    <font color="#0000E0">mov</font> <font color="#00B000">cx</font>,256              ;<font color="#808080"> number of pages to map (1 MB)</font>
@@:
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">add</font> <font color="#00B000">di</font>,4
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>,1000h
    <font color="#0000E0">loop</font> @B

;<font color="#808080">--- setup ebx/rbx with linear address of _TEXT</font>

    <font color="#0000E0">mov</font> <font color="#00B000">bx</font>,_TEXT
    <font color="#0000E0">movzx</font> <font color="#00B000">ebx</font>,<font color="#00B000">bx</font>
    <font color="#0000E0">shl</font> <font color="#00B000">ebx</font>,4
    <font color="#0000E0">add</font> [llg], <font color="#00B000">ebx</font>

;<font color="#808080">--- create IDT</font>

    <font color="#0000E0">mov</font> <font color="#00B000">di</font>,5000h
    <font color="#0000E0">mov</font> <font color="#00B000">cx</font>,32
    <font color="#0000E0">mov</font> <font color="#00B000">edx</font>, <font color="#808000">offset</font> exception
    <font color="#0000E0">add</font> <font color="#00B000">edx</font>, <font color="#00B000">ebx</font>
make_exc_gates:
    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">edx</font>
    <font color="#0000E0">stosw</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,8
    <font color="#0000E0">stosw</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,8E00h
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">xor</font> <font color="#00B000">eax</font>, <font color="#00B000">eax</font>
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">add</font> <font color="#00B000">edx</font>,4
    <font color="#0000E0">loop</font> make_exc_gates
    <font color="#0000E0">mov</font> <font color="#00B000">cx</font>,256-32
make_int_gates:
    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#808000">offset</font> interrupt
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, <font color="#00B000">ebx</font>
    <font color="#0000E0">stosw</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,8
    <font color="#0000E0">stosw</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,8E00h
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">xor</font> <font color="#00B000">eax</font>, <font color="#00B000">eax</font>
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">stosd</font>
    <font color="#0000E0">loop</font> make_int_gates

    <font color="#0000E0">mov</font> <font color="#00B000">di</font>,5000h
    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>, <font color="#00B000">ebx</font>
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, <font color="#808000">offset</font> clock
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+80h*16+0],<font color="#00B000">ax</font> ;<font color="#808080"> set IRQ 0 handler</font>
    <font color="#0000E0">shr</font> <font color="#00B000">eax</font>,16
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+80h*16+6],<font color="#00B000">ax</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>, <font color="#00B000">ebx</font>
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, <font color="#808000">offset</font> keyboard
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+81h*16+0],<font color="#00B000">ax</font> ;<font color="#808080"> set IRQ 1 handler</font>
    <font color="#0000E0">shr</font> <font color="#00B000">eax</font>,16
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>:[<font color="#00B000">di</font>+81h*16+6],<font color="#00B000">ax</font>

;<font color="#808080">--- clear NT flag</font>

    <font color="#0000E0">pushf</font>
    <font color="#0000E0">pop</font> <font color="#00B000">ax</font>
    <font color="#0000E0">and</font> <font color="#00B000">ah</font>,0BFh
    <font color="#0000E0">push</font> <font color="#00B000">ax</font>
    <font color="#0000E0">popf</font>

;<font color="#808080">--- reprogram PIC: change IRQ 0-7 to INT 80h-87h, IRQ 8-15 to INT 88h-8Fh</font>

    <font color="#0000E0">cli</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,0A1h
    <font color="#0000E0">mov</font> <font color="#00B000">ah</font>,<font color="#00B000">al</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,21h
    <font color="#0000E0">mov</font> [wPICMask],<font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,10001b       ;<font color="#808080"> begin PIC 1 initialization</font>
    <font color="#0000E0">out</font> 20h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,10001b       ;<font color="#808080"> begin PIC 2 initialization</font>
    <font color="#0000E0">out</font> 0A0h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,80h          ;<font color="#808080"> IRQ 0-7: interrupts 80h-87h</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,88h          ;<font color="#808080"> IRQ 8-15: interrupts 88h-8Fh</font>
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,100b         ;<font color="#808080"> slave connected to IRQ2</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,2
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,1            ;<font color="#808080"> Intel environment, manual EOI</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,21h
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,11111100b    ;<font color="#808080"> enable only clock and keyboard IRQ</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,0A1h
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,11111111b
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">cr4</font>
    <font color="#0000E0">or</font> <font color="#00B000">eax</font>,1 <font color="#0000E0">shl</font> 5
    <font color="#0000E0">mov</font> <font color="#00B000">cr4</font>,<font color="#00B000">eax</font>         ;<font color="#808080"> enable physical-address extensions (PAE)</font>

    <font color="#0000E0">mov</font> <font color="#00B000">ecx</font>,0C0000080h  ;<font color="#808080"> EFER MSR</font>
    <font color="#0000E0">rdmsr</font>
    <font color="#0000E0">or</font> <font color="#00B000">eax</font>,1 <font color="#0000E0">shl</font> 8      ;<font color="#808080"> enable long mode</font>
    <font color="#0000E0">wrmsr</font>

    <font color="#0000E0">lgdt</font> [GDTR]
    <font color="#0000E0">lidt</font> [IDTR]

    <font color="#0000E0">mov</font> <font color="#00B000">cx</font>,<font color="#00B000">ss</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">ecx</font>,<font color="#00B000">cx</font>        ;<font color="#808080"> get base of SS</font>
    <font color="#0000E0">shl</font> <font color="#00B000">ecx</font>,4
    <font color="#0000E0">movzx</font> <font color="#00B000">esp</font>,<font color="#00B000">sp</font>
    <font color="#0000E0">add</font> <font color="#00B000">ecx</font>, <font color="#00B000">esp</font>        ;<font color="#808080"> ECX=linear address of current SS:ESP</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">cr0</font>
    <font color="#0000E0">or</font> <font color="#00B000">eax</font>,80000001h
    <font color="#0000E0">mov</font> <font color="#00B000">cr0</font>,<font color="#00B000">eax</font>         ;<font color="#808080"> enable paging + pmode</font>

    <b>db</b> 66h, 0EAh        ;<font color="#808080"> jmp 0008:oooooooo</font>
llg <b>dd</b> <font color="#808000">offset</font> long_start
    <b>dw</b> 8

;<font color="#808080">--- switch back to real-mode and exit</font>

backtoreal:
    <font color="#0000E0">cli</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">cr0</font>
    <font color="#0000E0">and</font> <font color="#00B000">eax</font>,7FFFFFFFh   ;<font color="#808080"> disable paging</font>
    <font color="#0000E0">mov</font> <font color="#00B000">cr0</font>,<font color="#00B000">eax</font>

    <font color="#0000E0">mov</font> <font color="#00B000">ecx</font>,0C0000080h  ;<font color="#808080"> EFER MSR</font>
    <font color="#0000E0">rdmsr</font>
    <font color="#0000E0">and</font> <font color="#00B000">ah</font>,<font color="#0000E0">not</font> 1h       ;<font color="#808080"> disable long mode (EFER.LME=0)</font>
    <font color="#0000E0">wrmsr</font>

    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,24           ;<font color="#808080"> set SS,DS and ES to 64k data</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ss</font>,<font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ds</font>,<font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">es</font>,<font color="#00B000">ax</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">cr0</font>         ;<font color="#808080"> switch to real mode</font>
    <font color="#0000E0">and</font> <font color="#00B000">al</font>,0FEh
    <font color="#0000E0">mov</font> <font color="#00B000">cr0</font>, <font color="#00B000">eax</font>

    <b>db</b> 0eah             ;<font color="#808080"> clear instruction cache, CS=real-mode seg</font>
    <b>dw</b> $+4
    <b>dw</b> _TEXT16

    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,STACK        ;<font color="#808080"> SS=real-mode seg</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ss</font>, <font color="#00B000">ax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">sp</font>,4096

    <font color="#0000E0">push</font> <font color="#00B000">cs</font>             ;<font color="#808080"> DS=real-mode _TEXT16 seg</font>
    <font color="#0000E0">pop</font> <font color="#00B000">ds</font>

    <font color="#0000E0">lidt</font> [nullidt]      ;<font color="#808080"> IDTR=real-mode compatible values</font>

    <font color="#0000E0">mov</font> <font color="#00B000">eax</font>,<font color="#00B000">cr4</font>
    <font color="#0000E0">and</font> <font color="#00B000">al</font>,<font color="#0000E0">not</font> 20h      ;<font color="#808080"> disable physical-address extensions (PAE)</font>
    <font color="#0000E0">mov</font> <font color="#00B000">cr4</font>,<font color="#00B000">eax</font>

;<font color="#808080">--- reprogram PIC: change IRQ 0-7 to INT 08h-0Fh, IRQ 8-15 to INT 70h-77h</font>

    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,10001b       ;<font color="#808080"> begin PIC 1 initialization</font>
    <font color="#0000E0">out</font> 20h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,10001b       ;<font color="#808080"> begin PIC 2 initialization</font>
    <font color="#0000E0">out</font> 0A0h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,08h          ;<font color="#808080"> IRQ 0-7: back to ints 8h-Fh</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,70h          ;<font color="#808080"> IRQ 8-15: back to ints 70h-77h</font>
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,100b         ;<font color="#808080"> slave connected to IRQ2</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,2
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,1            ;<font color="#808080"> Intel environment, manual EOI</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,21h

    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,[wPICMask]   ;<font color="#808080"> restore PIC masks</font>
    <font color="#0000E0">out</font> 21h,<font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,<font color="#00B000">ah</font>
    <font color="#0000E0">out</font> 0A1h,<font color="#00B000">al</font>

    <font color="#0000E0">sti</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,4c00h
    <font color="#0000E0">int</font> 21h

_TEXT16 <b>ends</b>

;<font color="#808080">--- here's the 64bit code segment.</font>
;<font color="#808080">--- since 64bit code is always flat but the DOS mz format is segmented,</font>
;<font color="#808080">--- there are restrictions, because the assembler doesn't know the</font>
;<font color="#808080">--- linear address where the 64bit segment will be loaded:</font>
;<font color="#808080">--- + direct addressing with constants isn't possible (mov [0B8000h],rax)</font>
;<font color="#808080">---   since the rip-relative address will be calculated wrong.</font>
;<font color="#808080">--- + 64bit offsets (mov rax, offset &lt;var&gt;) must be adjusted by the linear</font>
;<font color="#808080">---   address where the 64bit segment was loaded (is in rbx).</font>
;<font color="#808080">---</font>
;<font color="#808080">--- rbx must preserve linear address of _TEXT</font>

_TEXT <b>segment</b> para use64 public 'CODE'

    <b>assume</b> <font color="#00B000">ds</font>:FLAT, <font color="#00B000">es</font>:FLAT

long_start:

    <font color="#0000E0">xor</font> <font color="#00B000">eax</font>,<font color="#00B000">eax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ss</font>,<font color="#00B000">eax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">esp</font>,<font color="#00B000">ecx</font>
    <font color="#0000E0">sti</font>             ;<font color="#808080"> now interrupts can be used</font>
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> "Hello 64bit",10,0
nextcmd:
    <font color="#0000E0">mov</font> <font color="#00B000">r8b</font>,0       ;<font color="#808080"> r8b will be filled by the keyboard irq routine</font>
nocmd:
    <font color="#0000E0">cmp</font> <font color="#00B000">r8b</font>,0
    <font color="#0000E0">jz</font> nocmd
    <font color="#0000E0">cmp</font> <font color="#00B000">r8b</font>,1       ;<font color="#808080"> ESC?</font>
    <font color="#0000E0">jz</font> esc_pressed
    <font color="#0000E0">cmp</font> <font color="#00B000">r8b</font>,13h     ;<font color="#808080"> 'r'?</font>
    <font color="#0000E0">jz</font> r_pressed
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> "unknown key ",0
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,<font color="#00B000">r8b</font>
    <font color="#0000E0">call</font> WriteB
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,0
    jmp nextcmd

;<font color="#808080">--- 'r' key: display some register contents</font>

r_pressed:
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"cr0=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,<font color="#00B000">cr0</font>
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"cr2=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,<font color="#00B000">cr2</font>
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"cr3=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,<font color="#00B000">cr3</font>
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"cr4=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,<font color="#00B000">cr4</font>
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"cr8=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,<font color="#00B000">cr8</font>
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,0
    jmp nextcmd

;<font color="#808080">--- ESC: back to real-mode</font>

esc_pressed:
    jmp [bv]
bv  <b>label</b> <font color="#800000">fword</font>
    <b>dd</b> <font color="#808000">offset</font> backtoreal
    <b>dw</b> 16

;<font color="#808080">--- screen output helpers</font>

;<font color="#808080">--- scroll screen up one line</font>
;<font color="#808080">--- rsi = linear address start of last line</font>
;<font color="#808080">--- rbp = linear address of BIOS area (0x400)</font>
scroll_screen:
    <font color="#0000E0">cld</font>
    <font color="#0000E0">mov</font> <font color="#00B000">edi</font>,<font color="#00B000">esi</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">eax</font>,<font color="#800000">word</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+4Ah]
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">lea</font> <font color="#00B000">rsi</font>, [<font color="#00B000">rsi</font>+2*<font color="#00B000">rax</font>]
    <font color="#0000E0">mov</font> <font color="#00B000">cl</font>, [<font color="#00B000">rbp</font>+84h]
    <font color="#0000E0">mul</font> <font color="#00B000">cl</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ecx</font>,<font color="#00B000">eax</font>
    <font color="#0000E0">rep</font> <font color="#0000E0">movsw</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rcx</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ax</font>,0720h
    <font color="#0000E0">rep</font> <font color="#0000E0">stosw</font>
    <font color="#0000E0">ret</font>

WriteChr:
    <font color="#0000E0">push</font> <font color="#00B000">rbp</font>
    <font color="#0000E0">push</font> <font color="#00B000">rdi</font>
    <font color="#0000E0">push</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">push</font> <font color="#00B000">rbx</font>
    <font color="#0000E0">push</font> <font color="#00B000">rcx</font>
    <font color="#0000E0">push</font> <font color="#00B000">rdx</font>
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">edi</font>,0B8000h
    <font color="#0000E0">mov</font> <font color="#00B000">ebp</font>,400h
    <font color="#0000E0">cmp</font> <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+63h],0B4h
    <font color="#0000E0">jnz</font> @F
    <font color="#0000E0">xor</font> <font color="#00B000">di</font>,<font color="#00B000">di</font>
@@:
    <font color="#0000E0">movzx</font> <font color="#00B000">ebx</font>, <font color="#800000">word</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+4Eh]
    <font color="#0000E0">add</font> <font color="#00B000">edi</font>, <font color="#00B000">ebx</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">ebx</font>, <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+62h]
    <font color="#0000E0">mov</font> <font color="#00B000">esi</font>, <font color="#00B000">edi</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">ecx</font>, <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbx</font>*2+<font color="#00B000">rbp</font>+50h+1] ;<font color="#808080">ROW</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">eax</font>, <font color="#800000">word</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+4Ah]
    <font color="#0000E0">mul</font> <font color="#00B000">ecx</font>
    <font color="#0000E0">movzx</font> <font color="#00B000">edx</font>, <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbx</font>*2+<font color="#00B000">rbp</font>+50h]  ;<font color="#808080">COL</font>
    <font color="#0000E0">add</font> <font color="#00B000">eax</font>, <font color="#00B000">edx</font>
    <font color="#0000E0">mov</font> <font color="#00B000">dh</font>,<font color="#00B000">cl</font>
    <font color="#0000E0">lea</font> <font color="#00B000">edi</font>, [<font color="#00B000">rdi</font>+<font color="#00B000">rax</font>*2]
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>, [<font color="#00B000">rsp</font>]
    <font color="#0000E0">cmp</font> <font color="#00B000">al</font>, 10
    <font color="#0000E0">jz</font> newline
    <font color="#0000E0">mov</font> [<font color="#00B000">rdi</font>], <font color="#00B000">al</font>
    <font color="#0000E0">mov</font> <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rdi</font>+1], 07
    <font color="#0000E0">inc</font> <font color="#00B000">dl</font>
    <font color="#0000E0">cmp</font> <font color="#00B000">dl</font>, <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+4Ah]
    <font color="#0000E0">jb</font> @F
newline:
    <font color="#0000E0">mov</font> <font color="#00B000">dl</font>, 00
    <font color="#0000E0">inc</font> <font color="#00B000">dh</font>
    <font color="#0000E0">cmp</font> <font color="#00B000">dh</font>, <font color="#800000">byte</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+84h]
    <font color="#0000E0">jbe</font> @F
    <font color="#0000E0">dec</font> <font color="#00B000">dh</font>
    <font color="#0000E0">call</font> scroll_screen
@@:
    <font color="#0000E0">mov</font> [<font color="#00B000">rbx</font>*2+<font color="#00B000">rbp</font>+50h],<font color="#00B000">dx</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rdx</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rcx</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rbx</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rdi</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rbp</font>
    <font color="#0000E0">ret</font>

WriteStr:   ;<font color="#808080">write string in rdx</font>
    <font color="#0000E0">push</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">mov</font> <font color="#00B000">rsi</font>, <font color="#00B000">rdx</font>
    <font color="#0000E0">cld</font>
@@:
    <font color="#0000E0">lodsb</font>
    <font color="#0000E0">and</font> <font color="#00B000">al</font>,<font color="#00B000">al</font>
    <font color="#0000E0">jz</font> @F
    <font color="#0000E0">call</font> WriteChr
    jmp @B
@@:
    <font color="#0000E0">pop</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">ret</font>

WriteStrX:  ;<font color="#808080">write string at rip</font>
    <font color="#0000E0">push</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">mov</font> <font color="#00B000">rsi</font>, [<font color="#00B000">rsp</font>+8]
    <font color="#0000E0">cld</font>
@@:
    <font color="#0000E0">lodsb</font>
    <font color="#0000E0">and</font> <font color="#00B000">al</font>,<font color="#00B000">al</font>
    <font color="#0000E0">jz</font> @F
    <font color="#0000E0">call</font> WriteChr
    jmp @B
@@:
    <font color="#0000E0">mov</font> [<font color="#00B000">rsp</font>+8],<font color="#00B000">rsi</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rsi</font>
    <font color="#0000E0">ret</font>

WriteQW:        ;<font color="#808080">write QWord in rax</font>
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">shr</font> <font color="#00B000">rax</font>,32
    <font color="#0000E0">call</font> WriteDW
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
WriteDW:
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">shr</font> <font color="#00B000">rax</font>,16
    <font color="#0000E0">call</font> WriteW
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
WriteW:
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">shr</font> <font color="#00B000">rax</font>,8
    <font color="#0000E0">call</font> WriteB
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
WriteB:     ;<font color="#808080">write Byte in al</font>
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">shr</font> <font color="#00B000">rax</font>,4
    <font color="#0000E0">call</font> WriteNb
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
WriteNb:
    <font color="#0000E0">and</font> <font color="#00B000">al</font>,0Fh
    <font color="#0000E0">add</font> <font color="#00B000">al</font>,'0'
    <font color="#0000E0">cmp</font> <font color="#00B000">al</font>,'9'
    <font color="#0000E0">jbe</font> @F
    <font color="#0000E0">add</font> <font color="#00B000">al</font>,7
@@:
    jmp WriteChr

;<font color="#808080">--- exception handler</font>

exception:
excno = 0
    <b>repeat</b> 32
    <font color="#0000E0">push</font> excno
    jmp @F
    excno = excno+1
    <b>endm</b>
@@:
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,"Exception ",0
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
    <font color="#0000E0">call</font> WriteB
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> " errcode=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,[<font color="#00B000">rsp</font>+0]
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> " rip=",0
    <font color="#0000E0">mov</font> <font color="#00B000">rax</font>,[<font color="#00B000">rsp</font>+8]
    <font color="#0000E0">call</font> WriteQW
    <font color="#0000E0">call</font> WriteStrX
    <b>db</b> 10,0
@@:
    jmp $

;<font color="#808080">--- clock and keyboard interrupts</font>

clock:
    <font color="#0000E0">push</font> <font color="#00B000">rbp</font>
    <font color="#0000E0">mov</font> <font color="#00B000">ebp</font>,400h
    <font color="#0000E0">inc</font> <font color="#800000">dword</font> <font color="#808000">ptr</font> [<font color="#00B000">rbp</font>+6Ch]
    <font color="#0000E0">pop</font> <font color="#00B000">rbp</font>
interrupt:              ;<font color="#808080"> handler for all other interrupts</font>
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,20h
    <font color="#0000E0">out</font> 20h,<font color="#00B000">al</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
    iretq

keyboard:
    <font color="#0000E0">push</font> <font color="#00B000">rax</font>
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,60h
    <font color="#0000E0">test</font> <font color="#00B000">al</font>,80h
    <font color="#0000E0">jnz</font> @F
    <font color="#0000E0">mov</font> <font color="#00B000">r8b</font>, <font color="#00B000">al</font>
@@:
    <font color="#0000E0">in</font> <font color="#00B000">al</font>,61h           ;<font color="#808080"> give finishing information</font>
    <font color="#0000E0">out</font> 61h,<font color="#00B000">al</font>          ;<font color="#808080"> to keyboard...</font>
    <font color="#0000E0">mov</font> <font color="#00B000">al</font>,20h
    <font color="#0000E0">out</font> 20h,<font color="#00B000">al</font>          ;<font color="#808080"> ...and interrupt controller</font>
    <font color="#0000E0">pop</font> <font color="#00B000">rax</font>
    iretq

_TEXT <b>ends</b>

;<font color="#808080">--- 4k stack, used in both modes</font>

STACK <b>segment</b> use16 para stack 'STACK'
    <b>db</b> 4096 <font color="#808000">dup</font> (?)
STACK <b>ends</b>

    <b>end</b> start16
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB04"> Win32_5 - Create a Win32 Binary with -bin </H2>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- Win32 "hello world" console application.</font>
;<font color="#808080">--- Uses JWasm's bin output format, so no linker needed.</font>
;<font color="#808080">--- assemble: JWasm -bin -Fo Win32_5.exe Win32_5.ASM</font>

    <b>.386</b>
    <b>option</b> casemap:none

    <b>.nolist</b>
    <b>include</b> winnt.inc   ;<font color="#808080">include PE image definitions</font>
    <b>.list</b>

STD_OUTPUT_HANDLE <b>equ</b> -11

IMAGEBASE <b>equ</b> 400000h

PEHDR <b>segment</b> dword FLAT

;<font color="#808080">--- define the DOS "MZ" header</font>

    <b>org</b> IMAGEBASE

    IMAGE_DOS_HEADER &lt;"ZM", 80h, 1, 0,4,0,-1,0,200h,0,0,0,0,0,&lt;0&gt;,0,0,&lt;0&gt;,IMAGEREL PEHdr&gt;

    <b>db</b> 0Eh         ;<font color="#808080">push cs</font>
    <b>db</b> 1Fh         ;<font color="#808080">pop ds</font>
    <b>db</b> 0BAh,0Eh,0  ;<font color="#808080">mov dx,text</font>
    <b>db</b> 0B4h,09h    ;<font color="#808080">mov ah,9</font>
    <b>db</b> 0CDh,21h    ;<font color="#808080">int 21h</font>
    <b>db</b> 0B8h,01h,4Ch;<font color="#808080">mov ax,4c01h</font>
    <b>db</b> 0CDh,21h    ;<font color="#808080">int 21h</font>
    <b>db</b> "This program cannot be run in DOS mode",13,10,'$'

    <b>org</b> IMAGEBASE+80h

;<font color="#808080">--- define the Win32 "PE" header</font>

PEHdr <b>label</b> byte
    <b>db</b> "PE",0,0
    IMAGE_FILE_HEADER &lt;IMAGE_FILE_MACHINE_I386, num_sections, 0, 0, 0, sizeof IMAGE_OPTIONAL_HEADER32,
        IMAGE_FILE_RELOCS_STRIPPED or IMAGE_FILE_EXECUTABLE_IMAGE or IMAGE_FILE_32BIT_MACHINE or IMAGE_FILE_LOCAL_SYMS_STRIPPED&gt;

    IMAGE_OPTIONAL_HEADER32 { 10Bh, ;<font color="#808080">magic</font>
        6,0,                        ;<font color="#808080">linker major, minor</font>
        1000h,1000h,0,              ;<font color="#808080">sizeof code, initialized data, uninitialized data</font>
        IMAGEREL mainCRTStartup,    ;<font color="#808080">entry point</font>
        IMAGEREL start_text, IMAGEREL start_rdata,  ;<font color="#808080">baseof code, data</font>
        IMAGEBASE,    ;<font color="#808080">imagebase</font>
        1000h,200h,   ;<font color="#808080">section alignment, file alignment</font>
        4,0,          ;<font color="#808080">OS major, minor</font>
        0,0,          ;<font color="#808080">Image major, minor</font>
        4,0,          ;<font color="#808080">Subsys major, minor</font>
        0,            ;<font color="#808080">win32 version</font>
        3000h,        ;<font color="#808080">sizeof image</font>
        1000h,        ;<font color="#808080">sizeof header</font>
        0,            ;<font color="#808080">checksum</font>
        IMAGE_SUBSYSTEM_WINDOWS_CUI,
        0,            ;<font color="#808080">dll characteristics</font>
        100000h,1000h,;<font color="#808080">stack res,com</font>
        100000h,1000h,;<font color="#808080">heap res, com</font>
        0,            ;<font color="#808080">loader flags</font>
        16,           ;<font color="#808080">number of directories</font>
        &lt;&lt;0,0&gt;,       ;exports
        &lt; IMAGEREL start_idata, SECTIONREL endof_idata &gt;, ;<font color="#808080">imports</font>
        &lt;0,0&gt;,&lt;0,0&gt;,     ;<font color="#808080">resource, exception</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;,     ;<font color="#808080">security, baserelocs, debug, architecture</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;,     ;<font color="#808080">globalptr, tls, load_config, bound_import</font>
        &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;&gt;}    ;<font color="#808080">iat, delay_import, com descriptor, reserved</font>

;<font color="#808080">--- define the section table</font>

sectiontable <b>label</b> byte
    IMAGE_SECTION_HEADER &lt;".text", &lt;sizeof_text&gt;, IMAGEREL start_text, sizeof_text,
        200h, 0, 0, 0, 0, 060000020h &gt;
    IMAGE_SECTION_HEADER &lt;".rdata", &lt;SECTIONREL endof_idata + sizeof_const&gt;, IMAGEREL start_rdata, SECTIONREL endof_idata + sizeof_const,
        400h, 0, 0, 0, 0, 040000040h &gt;
num_sections <b>equ</b> ( $ -  sectiontable ) / sizeof IMAGE_SECTION_HEADER

    <b>org</b> IMAGEBASE+200h   ;<font color="#808080">forces physical size of header to 200h and sets VA to 400200h</font>

PEHDR <b>ends</b>

;<font color="#808080">--- the ALIGNx segments are needed because</font>
;<font color="#808080">--- section alignment and file alignment are different</font>

ALIGN1 <b>segment</b> dword public FLAT 'DATA'
    <b>org</b> 0E00h   ;<font color="#808080"> change pc to RVA 1000h</font>
ALIGN1 <b>ends</b>

_TEXT <b>segment</b> dword public FLAT 'CODE'
_TEXT <b>ends</b>

ALIGN2 <b>segment</b> dword public FLAT 'DATA'
    <b>org</b> 0E00h   ;<font color="#808080"> change pc to RVA 2000h</font>
ALIGN2 <b>ends</b>

_IDATA <b>segment</b> dword public FLAT 'DATA'
start_rdata <b>label</b> byte
start_idata <b>label</b> byte
;<font color="#808080">--- import descriptors go here</font>
_IDATA <b>ends</b>
_IDATA$1 <b>segment</b> dword public FLAT 'DATA'
    IMAGE_IMPORT_DESCRIPTOR &lt;&lt;0&gt;,0,0,0,0&gt;
;<font color="#808080">--- ILT entries go here</font>
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b> dword public FLAT 'DATA'
    <b>dd</b> 0    ;<font color="#808080">--- end of last ILT</font>
;<font color="#808080">--- IAT entries go here</font>
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b> dword public FLAT 'DATA'
    <b>dd</b> 0    ;<font color="#808080">--- end of last IAT</font>
;<font color="#808080">--- import name strings go here</font>
_IDATA$3 <b>ends</b>
_IDATA$4 <b>segment</b> dword public FLAT 'DATA'
endof_idata <b>equ</b> $
_IDATA$4 <b>ends</b>

CONST <b>segment</b> dword public FLAT 'DATA'
start_const <b>label</b> byte
CONST <b>ends</b>

DefineImpDll <b>macro</b> name
_IDATA <b>segment</b>
    IMAGE_IMPORT_DESCRIPTOR &lt;&lt;IMAGEREL name&amp;ILT&gt;,0,0,IMAGEREL name, IMAGEREL name&amp;IAT&gt;
_IDATA <b>ends</b>
_IDATA$1 <b>segment</b>
<b>ifdef</b> ImportDefined
    <b>dd</b> 0  ;<font color="#808080">terminate previous ILT</font>
<b>endif</b>
<b>name</b>&amp;ILT label dword
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b>
<b>ifdef</b> ImportDefined
    <b>dd</b> 0  ;<font color="#808080">terminate previous IAT</font>
<b>endif</b>
<b>name</b>&amp;IAT label dword
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b>
<b>name</b> db @CatStr(!",name, !"),0
    <b>align</b> 4
_IDATA$3 <b>ends</b>
ImportDefined <b>equ</b> 1
    <b>endm</b>

DefineImport <b>macro</b> name
_IDATA$1 <b>segment</b>
    <b>dd</b> IMAGEREL n&amp;name
_IDATA$1 <b>ends</b>
_IDATA$2 <b>segment</b>
lp&amp;<b>name</b> typedef ptr pr&amp;name
<b>name</b>    lp&amp;name IMAGEREL n&amp;name
_IDATA$2 <b>ends</b>
_IDATA$3 <b>segment</b>
n&amp;<b>name</b> dw 0
    <b>db</b> @CatStr(!",name, !"),0
    <b>align</b> 4
_IDATA$3 <b>ends</b>
    <b>endm</b>

prWriteConsoleA <b>typedef</b> proto stdcall :dword, :dword, :dword, :dword, :dword
prGetStdHandle  <b>typedef</b> proto stdcall :dword
prExitProcess   <b>typedef</b> proto stdcall :dword

    DefineImpDll kernel32
    DefineImport ExitProcess
    DefineImport WriteConsoleA
    DefineImport GetStdHandle

<b>if</b> 0 ;<font color="#808080">if further dlls are to be imported</font>
prMessageBoxA   <b>typedef</b> proto stdcall :dword, :dword, :dword, :dword

    DefineImpDll user32
    DefineImport MessageBoxA
<b>endif</b>

CONST <b>segment</b>

string  <b>db</b> 13,10,"hello, world.",13,10

sizeof_const <b>equ</b> $ - start_const

CONST <b>ends</b>

_TEXT <b>segment</b>

    <b>assume</b> ds:FLAT,es:FLAT

start_text <b>label</b> near

;<font color="#808080">--- start of program</font>

main <b>proc</b>

<b>local</b> dwWritten:dword
<b>local</b> hConsole:dword

    <b>invoke</b>  GetStdHandle, STD_OUTPUT_HANDLE
    mov     hConsole,eax

    <b>invoke</b>  WriteConsoleA, hConsole, addr string, sizeof string, addr dwWritten, 0

    xor     eax,eax
    ret
main <b>endp</b>

;<font color="#808080">--- entry</font>

mainCRTStartup <b>proc</b> c

    <b>invoke</b>  main
    <b>invoke</b>  ExitProcess, eax

mainCRTStartup <b>endp</b>

sizeof_text <b>equ</b> $ - start_text

    <b>org</b> 200h    ;<font color="#808080">align size of _TEXT to next 512 byte boundary</font>

_TEXT <b>ends</b>

    <b>end</b>
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB05"> Win32_7 - Usage of OPTION DLLIMPORT and -Fd Switch </H2>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- Win32_7 - Shows how to use OPTION DLLIMPORT and switch -Fd.</font>
;<font color="#808080">---           No import libraries are needed in the link step.</font>
;<font color="#808080">---</font>
;<font color="#808080">--- assemble: JWasm -coff -Fd Win32_7.ASM</font>
;<font color="#808080">--- link:     JWlink format windows pe f Win32_7.OBJ</font>

    <b>.386</b>
    <b>.model</b> FLAT, stdcall
    <b>option</b> casemap:none

STD_OUTPUT_HANDLE <b>equ</b> -11

   <b>option</b> dllimport:&lt;kernel32&gt;
WriteConsoleA <b>proto</b> :dword, :dword, :dword, :dword, :dword
GetStdHandle  <b>proto</b> :dword
ExitProcess   <b>proto</b> :dword
   <b>option</b> dllimport:&lt;user32&gt;
MessageBoxA   <b>proto</b> :dword, :dword, :dword, :dword
   <b>option</b> dllimport:&lt;none&gt;

    <b>.const</b>

msg <b>db</b> 13,10,"hello, world.",13,10
    <b>db</b> 0

    <b>.code</b>

main <b>proc</b>

<b>local</b>   written:dword

    <b>invoke</b>  GetStdHandle, STD_OUTPUT_HANDLE
    mov ebx, eax
    <b>invoke</b>  WriteConsoleA, ebx, addr msg, sizeof msg,
                addr written, 0
    <b>invoke</b>  MessageBoxA, 0, addr msg, 0, 0
    ret

main <b>endp</b>

;<font color="#808080">--- entry</font>

start:

    <b>invoke</b>  main
    <b>invoke</b>  ExitProcess, 0

    <b>end</b> start
</pre>
</TD></TR>
</TABLE>

<H2 ID="AB06"> Win64_8 - Create a Win64 Binary with -pe </H2>

<TABLE BORDER=0 CELLSPACING=4 CELLPADDING=4 WIDTH="100%">
<TR BGCOLOR="#E0E0E0"><TD>
<pre>

;<font color="#808080">--- create a 64-bit binary with -pe cmdline option</font>
;<font color="#808080">---</font>
;<font color="#808080">---   JWasm -pe Win64_8.asm</font>

    <b>.x64</b>                ;<font color="#808080"> -pe requires to set cpu, model &amp; language</font>
    <b>.model</b> flat, fastcall

    <b>option</b> casemap:none
    <b>option</b> frame:auto   ;<font color="#808080"> generate SEH-compatible prologues and epilogues</font>
    <b>option</b> win64:3      ;<font color="#808080"> init shadow space, reserve stack at PROC level</font>

;<font color="#808080">--- resource IDs</font>
IDR_MENU1   <b>equ</b> 100
IDR_BITMAP1 <b>equ</b> 101
IDM_EXIT    <b>equ</b> 1000

NULL      <b>equ</b> 0
LPSTR     <b>typedef</b> <font color="#808000">ptr</font>
LPVOID    <b>typedef</b> <font color="#808000">ptr</font>
UINT      <b>typedef</b> <font color="#800000">dword</font>
BOOL      <b>typedef</b> <font color="#800000">dword</font>

;<font color="#808080">--- winbase definitions</font>
HINSTANCE <b>typedef</b> <font color="#808000">ptr</font>

;<font color="#808080">--- winuser definitions</font>
HWND      <b>typedef</b> <font color="#808000">ptr</font>
HMENU     <b>typedef</b> <font color="#808000">ptr</font>
HICON     <b>typedef</b> <font color="#808000">ptr</font>
HBRUSH    <b>typedef</b> <font color="#808000">ptr</font>
HCURSOR   <b>typedef</b> <font color="#808000">ptr</font>
HDC       <b>typedef</b> <font color="#808000">ptr</font>
HBITMAP   <b>typedef</b> <font color="#808000">ptr</font>
WPARAM    <b>typedef</b> <font color="#808000">ptr</font>
LPARAM    <b>typedef</b> <font color="#800000">qword</font>

WS_OVERLAPPEDWINDOW <b>equ</b> 0CF0000h
CW_USEDEFAULT  <b>equ</b> 80000000h
SW_SHOWDEFAULT <b>equ</b> 10
SW_SHOWNORMAL  <b>equ</b> 1
IDC_ARROW      <b>equ</b> 32512
IDI_APPLICATION <b>equ</b> 32512
CS_VREDRAW     <b>equ</b> 1
CS_HREDRAW     <b>equ</b> 2
COLOR_WINDOW   <b>equ</b> 5

WM_DESTROY     <b>equ</b> 2
WM_PAINT       <b>equ</b> 000Fh
WM_COMMAND     <b>equ</b> 0111h

proto_WNDPROC <b>typedef</b> proto :HWND,:<font color="#800000">qword</font>,:WPARAM,:LPARAM
WNDPROC <b>typedef</b> <font color="#808000">ptr</font> proto_WNDPROC

WNDCLASSEXA <b>struct</b> 8
cbSize          <font color="#800000">dword</font>   ?
style           <font color="#800000">dword</font>   ?
lpfnWndProc     WNDPROC ?
cbClsExtra      <font color="#800000">dword</font>   ?
cbWndExtra      <font color="#800000">dword</font>   ?
hInstance       HINSTANCE ?
hIcon           HICON   ?
hCursor         HCURSOR ?
hbrBackground   HBRUSH  ?
lpszMenuName    LPSTR   ?
lpszClassName   LPSTR   ?
hIconSm         HICON   ?
WNDCLASSEXA <b>ends</b>

POINT   <b>struct</b>
x   <font color="#800000">sdword</font>  ?
y   <font color="#800000">sdword</font>  ?
POINT   <b>ends</b>

MSG <b>struct</b> 8
hwnd    HWND    ?
message <font color="#800000">dword</font>   ?
wParam  WPARAM  ?
lParam  LPARAM  ?
time    <font color="#800000">dword</font>   ?
pt      POINT   &lt;&gt;
MSG <b>ends</b>

RECT <b>struct</b>
left    <font color="#800000">sdword</font>  ?
top     <font color="#800000">sdword</font>  ?
right   <font color="#800000">sdword</font>  ?
bottom  <font color="#800000">sdword</font>  ?
RECT <b>ends</b>

PAINTSTRUCT <b>struct</b> 8
hdc         HDC  ?
fErase      BOOL ?
rcPaint     RECT &lt;&gt;
fRestore    BOOL ?
fIncUpdate  BOOL ?
rgbReserved <font color="#800000">byte</font> 32 <font color="#808000">dup</font> (?)
PAINTSTRUCT <b>ends</b>

;<font color="#808080">--- wingdi definitions</font>

DIB_RGB_COLORS  <b>equ</b> 0
SRCCOPY         <b>equ</b> 00CC0020h

HGDIOBJ  <b>typedef</b> <font color="#808000">ptr</font>

BITMAPINFOHEADER <b>struct</b>
biSize          <font color="#800000">dword</font>   ?
biWidth         <font color="#800000">sdword</font>  ?
biHeight        <font color="#800000">sdword</font>  ?
biPlanes        <font color="#800000">word</font>    ?
biBitCount      <font color="#800000">word</font>    ?
biCompression   <font color="#800000">dword</font>   ?
biSizeImage     <font color="#800000">dword</font>   ?
biXPelsPerMeter <font color="#800000">sdword</font>  ?
biYPelsPerMeter <font color="#800000">sdword</font>  ?
biClrUsed       <font color="#800000">dword</font>   ?
biClrImportant  <font color="#800000">dword</font>   ?
BITMAPINFOHEADER <b>ends</b>

    <b>option</b> dllimport:&lt;kernel32&gt;
GetModuleHandleA <b>proto</b> :LPSTR
GetCommandLineA  <b>proto</b>
ExitProcess      <b>proto</b> :UINT

    <b>option</b> dllimport:&lt;user32&gt;
BeginPaint       <b>proto</b> :HWND, :<font color="#808000">ptr</font> PAINTSTRUCT
CreateWindowExA  <b>proto</b> :<font color="#800000">dword</font>, :LPSTR, :LPSTR, :<font color="#800000">dword</font>, :<font color="#800000">sdword</font>, :<font color="#800000">sdword</font>, :<font color="#800000">sdword</font>, :<font color="#800000">sdword</font>, :HWND, :HMENU, :HINSTANCE, :LPVOID
DefWindowProcA   <b>proto</b> :HWND, :UINT, :WPARAM, :LPARAM
DestroyWindow    <b>proto</b> :HWND
DispatchMessageA <b>proto</b> :<font color="#808000">ptr</font> MSG
EndPaint         <b>proto</b> :HWND, :<font color="#808000">ptr</font> PAINTSTRUCT
GetClientRect    <b>proto</b> :HWND, :<font color="#808000">ptr</font> RECT
GetMessageA      <b>proto</b> :<font color="#808000">ptr</font> MSG, :HWND, :<font color="#800000">sdword</font>, :<font color="#800000">sdword</font>
LoadBitmapA      <b>proto</b> :HINSTANCE, :LPSTR
LoadCursorA      <b>proto</b> :HINSTANCE, :LPSTR
LoadIconA        <b>proto</b> :HINSTANCE, :LPSTR
PostQuitMessage  <b>proto</b> :<font color="#800000">sdword</font>
RegisterClassExA <b>proto</b> :<font color="#808000">ptr</font> WNDCLASSEXA
ShowWindow       <b>proto</b> :HWND, :<font color="#800000">sdword</font>
TranslateMessage <b>proto</b> :<font color="#808000">ptr</font> MSG
UpdateWindow     <b>proto</b> :HWND

    <b>option</b> DLLIMPORT:&lt;gdi32&gt;
BitBlt             <b>proto</b> :HDC, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>, :HDC, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>
CreateCompatibleDC <b>proto</b> :HDC
DeleteDC           <b>proto</b> :HDC
GetDIBits          <b>proto</b> :HDC, :HBITMAP, :<font color="#800000">dword</font>, :<font color="#800000">dword</font>, :<font color="#808000">ptr</font>, :<font color="#808000">ptr</font> BITMAPINFO, :<font color="#800000">dword</font>
SelectObject       <b>proto</b> :HDC, :HGDIOBJ
    <b>option</b> dllimport:none

WinMain <b>proto</b> :HINSTANCE, :HINSTANCE, :LPSTR, :UINT

    <b>.data</b>

ClassName <b>db</b> "SimpleWinClass",0
AppName  <b>db</b> "Bitmap rendering",0

    <b>.data?</b>

hInstance HINSTANCE ?
hBitmap   HBITMAP ?
CommandLine LPSTR ?

    <b>.code</b>

WinMainCRTStartup <b>proc</b> FRAME

    <b>invoke</b> GetModuleHandleA, NULL
    <font color="#0000E0">mov</font>    hInstance, <font color="#00B000">rax</font>
    <b>invoke</b> GetCommandLineA
    <font color="#0000E0">mov</font>    CommandLine, <font color="#00B000">rax</font>
    <b>invoke</b> WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT
    <b>invoke</b> ExitProcess, <font color="#00B000">eax</font>

WinMainCRTStartup <b>endp</b>

WinMain <b>proc</b> FRAME hInst:HINSTANCE, hPrevInst:HINSTANCE, CmdLine:LPSTR, CmdShow:UINT

    <b>local</b> wc:WNDCLASSEXA
    <b>local</b> msg:MSG
    <b>local</b> hwnd:HWND

    <b>invoke</b> LoadBitmapA, hInst, IDR_BITMAP1
    <font color="#0000E0">mov</font>   hBitmap, <font color="#00B000">rax</font>

    <font color="#0000E0">mov</font>   wc.cbSize, <font color="#808000">sizeof</font> WNDCLASSEXA
    <font color="#0000E0">mov</font>   wc.style, CS_HREDRAW <font color="#0000E0">or</font> CS_VREDRAW
    <font color="#0000E0">lea</font>   <font color="#00B000">rax</font>, [WndProc]
    <font color="#0000E0">mov</font>   wc.lpfnWndProc, <font color="#00B000">rax</font>
    <font color="#0000E0">mov</font>   wc.cbClsExtra, NULL
    <font color="#0000E0">mov</font>   wc.cbWndExtra, NULL
    <font color="#0000E0">mov</font>   <font color="#00B000">rcx</font>, hInst
    <font color="#0000E0">mov</font>   wc.hInstance, <font color="#00B000">rcx</font>
    <font color="#0000E0">mov</font>   wc.hbrBackground, COLOR_WINDOW+1
    <font color="#0000E0">mov</font>   wc.lpszMenuName, IDR_MENU1
    <font color="#0000E0">lea</font>   <font color="#00B000">rax</font>, [ClassName]
    <font color="#0000E0">mov</font>   wc.lpszClassName, <font color="#00B000">rax</font>
    <b>invoke</b> LoadIconA, NULL, IDI_APPLICATION
    <font color="#0000E0">mov</font>   wc.hIcon, <font color="#00B000">rax</font>
    <font color="#0000E0">mov</font>   wc.hIconSm, <font color="#00B000">rax</font>
    <b>invoke</b> LoadCursorA, NULL, IDC_ARROW
    <font color="#0000E0">mov</font>   wc.hCursor,<font color="#00B000">rax</font>
    <b>invoke</b> RegisterClassExA, addr wc
    <b>invoke</b> CreateWindowExA, NULL, ADDR ClassName, ADDR AppName,
           WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,
           CW_USEDEFAULT, CW_USEDEFAULT,CW_USEDEFAULT, NULL, NULL,
           hInst, NULL
    <font color="#0000E0">mov</font>   hwnd,<font color="#00B000">rax</font>
    <b>invoke</b> ShowWindow, hwnd, SW_SHOWNORMAL
    <b>invoke</b> UpdateWindow, hwnd
    <b>.while</b> (1)
        <b>invoke</b> GetMessageA, ADDR msg, NULL, 0, 0
        <b>.break</b> .if (!<font color="#00B000">eax</font>)
        <b>invoke</b> TranslateMessage, ADDR msg
        <b>invoke</b> DispatchMessageA, ADDR msg
    <b>.endw</b>
    <font color="#0000E0">mov</font>   <font color="#00B000">rax</font>, msg.wParam
    <font color="#0000E0">ret</font>
WinMain <b>endp</b>

WndProc <b>proc</b> FRAME hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM

<b>local</b> hdc2:HDC
<b>local</b> ps:PAINTSTRUCT
<b>local</b> rect:RECT
<b>local</b> bmi:BITMAPINFOHEADER

    <b>.if</b> <font color="#00B000">edx</font> == WM_DESTROY
        <b>invoke</b> PostQuitMessage, NULL
        <font color="#0000E0">xor</font> <font color="#00B000">rax</font>,<font color="#00B000">rax</font>
    <b>.elseif</b> <font color="#00B000">edx</font> == WM_COMMAND
        <b>.if</b> wParam == IDM_EXIT
            <b>invoke</b> DestroyWindow, hWnd
        <b>.endif</b>
        <font color="#0000E0">xor</font> <font color="#00B000">eax</font>, <font color="#00B000">eax</font>
    <b>.elseif</b> <font color="#00B000">edx</font> == WM_PAINT
        <b>invoke</b> BeginPaint, hWnd, addr ps
        <b>invoke</b> CreateCompatibleDC, ps.hdc
        <font color="#0000E0">mov</font> hdc2, <font color="#00B000">rax</font>
        <b>invoke</b> SelectObject, hdc2, hBitmap
        <font color="#0000E0">mov</font> bmi.biSize, <font color="#808000">sizeof</font> BITMAPINFOHEADER
        <font color="#0000E0">mov</font> bmi.biBitCount, 0
        <b>invoke</b> GetDIBits, hdc2, hBitmap, 0, 0, 0, addr bmi, DIB_RGB_COLORS
        <b>invoke</b> GetClientRect, hWnd, addr rect
        <font color="#0000E0">mov</font> <font color="#00B000">r8d</font>, rect.right
        <font color="#0000E0">sub</font> <font color="#00B000">r8d</font>, bmi.biWidth
        <font color="#0000E0">jnc</font> @F
        <font color="#0000E0">xor</font> <font color="#00B000">r8d</font>, <font color="#00B000">r8d</font>
@@:
        <font color="#0000E0">shr</font> <font color="#00B000">r8d</font>, 1
        <font color="#0000E0">mov</font> <font color="#00B000">r9d</font>, rect.bottom
        <font color="#0000E0">sub</font> <font color="#00B000">r9d</font>, bmi.biHeight
        <font color="#0000E0">jnc</font> @F
        <font color="#0000E0">xor</font> <font color="#00B000">r9d</font>, <font color="#00B000">r9d</font>
@@:
        <font color="#0000E0">shr</font> <font color="#00B000">r9d</font>, 1
        <b>invoke</b> BitBlt, ps.hdc, <font color="#00B000">r8d</font>, <font color="#00B000">r9d</font>, bmi.biWidth, bmi.biHeight, hdc2, 0, 0, SRCCOPY
        <b>invoke</b> DeleteDC, hdc2
        <b>invoke</b> EndPaint, hWnd, addr ps

        <font color="#0000E0">xor</font> <font color="#00B000">eax</font>,<font color="#00B000">eax</font>
    <b>.else</b>
        <b>invoke</b> DefWindowProcA, <font color="#00B000">rcx</font>, <font color="#00B000">edx</font>, <font color="#00B000">r8</font>, <font color="#00B000">r9</font>
    <b>.endif</b>
    <font color="#0000E0">ret</font>
WndProc <b>endp</b>

<b>if</b> 1 ;<font color="#808080">for -pe</font>

RT_BITMAP <b>equ</b> 2
RT_MENU   <b>equ</b> 4

;<font color="#808080">--- menu resource flags</font>
MF_POPUP   <b>equ</b> 10h
MF_END     <b>equ</b> 80h

IMAGE_RESOURCE_DIRECTORY <b>struct</b>
Characteristics      <font color="#800000">dword</font> ?
TimeDateStamp        <font color="#800000">dword</font> ?
MajorVersion         <font color="#800000">word</font>  ?
MinorVersion         <font color="#800000">word</font>  ?
NumberOfNamedEntries <font color="#800000">word</font>  ?
NumberOfIdEntries    <font color="#800000">word</font>  ?
IMAGE_RESOURCE_DIRECTORY <b>ends</b>

IMAGE_RESOURCE_DIRECTORY_ENTRY <b>struct</b>
<b>union</b>
r0      <b>record</b> NameIsString:1, NameOffset:31
Name_   <font color="#800000">dword</font>   ?
Id      <font color="#800000">word</font>    ?
<b>ends</b>
<b>union</b>
OffsetToData <font color="#800000">dword</font>   ?
r1           <b>record</b>	DataIsDirectory:1, OffsetToDirectory:31
<b>ends</b>
IMAGE_RESOURCE_DIRECTORY_ENTRY <b>ends</b>

IMAGE_RESOURCE_DATA_ENTRY <b>struct</b>
OffsetToData <font color="#800000">dword</font> ?
Size_        <font color="#800000">dword</font> ?
CodePage     <font color="#800000">dword</font> ?
Reserved     <font color="#800000">dword</font> ?
IMAGE_RESOURCE_DATA_ENTRY <b>ends</b>

    <b>option</b> dotname

.rsrc <b>segment</b> <font color="#800000">dword</font> FLAT public read 'RSRC'

;<font color="#808080">--- define menu IDR_MENU1 and bitmap IDR_BITMAP1</font>

;<font color="#808080">--- root level: enum the resource types</font>
      IMAGE_RESOURCE_DIRECTORY &lt;0,0,0,0,0,2&gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;RT_BITMAP&gt;, &lt;SECTIONREL bms   + 80000000h&gt; &gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;RT_MENU&gt;,   &lt;SECTIONREL menus + 80000000h&gt; &gt;

;<font color="#808080">--- second level: enum the IDs of resource type X</font>
bms   IMAGE_RESOURCE_DIRECTORY &lt;0,0,0,0,0,1&gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;IDR_BITMAP1&gt;, &lt;SECTIONREL bm1   + 80000000h&gt; &gt;
menus IMAGE_RESOURCE_DIRECTORY &lt;0,0,0,0,0,1&gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;IDR_MENU1&gt;,   &lt;SECTIONREL menu1 + 80000000h&gt; &gt;

;<font color="#808080">--- third level: enum the languages of ID X</font>
bm1   IMAGE_RESOURCE_DIRECTORY &lt;0,0,0,0,0,1&gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;409h&gt;, &lt;SECTIONREL bm1_l1&gt; &gt;
menu1 IMAGE_RESOURCE_DIRECTORY &lt;0,0,0,0,0,1&gt;
      IMAGE_RESOURCE_DIRECTORY_ENTRY &lt; &lt;409h&gt;, &lt;SECTIONREL m1_l1&gt; &gt;

;<font color="#808080">--- last level: define the resource data</font>
;<font color="#808080">--- data for menu IDR_MENU1, language 409h</font>
m1_l1 IMAGE_RESOURCE_DATA_ENTRY &lt;IMAGEREL m1_l1_data, size_m1_l1, 0, 0&gt;
m1_l1_data <b>dw</b> 0,0	;<font color="#808080">menu header</font>
    <b>dw</b> MF_POPUP <font color="#0000E0">or</font> MF_END, '&amp;','F','i','l','e',0
    <b>dw</b> MF_END, IDM_EXIT,   'E','&amp;','x','i','t',0
size_m1_l1 <b>equ</b> $ - m1_l1_data
    <b>align</b> 4

;<font color="#808080">--- data for bitmap IDR_BITMAP1</font>
bm1_l1 IMAGE_RESOURCE_DATA_ENTRY &lt;IMAGEREL bm1_l1_data, size_bm1_l1, 0, 0&gt;
bm1_l1_data <b>label</b> <font color="#800000">word</font>
    <b>incbin</b> &lt;Win32_8.bmp&gt;,14	;<font color="#808080">skip bitmap file header</font>
size_bm1_l1 <b>equ</b> $ - ( bm1_l1_data )

.rsrc <b>ends</b>

;<font color="#808080">--- set /subsystem:windows</font>
;<font color="#808080">--- the PE header is stored in section .hdr$2</font>
    <b>option</b> dotname
.hdr$2 <b>segment</b> <font color="#800000">dword</font> FLAT public 'HDR'
    <b>org</b> 5Ch ;<font color="#808080">position to IMAGE_NT_HEADER64.OptionalHeader.Subsystem</font>
    <b>dw</b> 2    ;<font color="#808080">2=subsystem windows</font>
.hdr$2 <b>ends</b>

<b>endif</b>

<b>end</b> WinMainCRTStartup
</pre>
</TD></TR>
</TABLE>


<H1 ID="AC"> Appendix C. Errors and Warnings </H1>

    The warning and error numbers emitted by JWasm differ from Masm's.
    However, the texts of the messages are pretty much identical.<br>
    As in Masm, the first digit shows the severity of the issue: 
    range 1xxx reports a fatal error ( assembly process is stopped ),
    range 2xxx indicates an error ( assembly process continues, but no object module will be created )
    and 4xxx are warnings.
    

<TABLE CELLSPACING=4 CELLPADDING=4 > 

<TR BGCOLOR="#F0F0F0">
<TD><b>x029</b></TD>
<TD>Multiple base registers not allowed</TD>
<TD>In 16-bit code, one cannot use both BX and BP in indirect addressing; 
in 32/64-bit code, ESP/RSP can only appear once in indirect addressing.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x030</b></TD>
<TD>Instruction or register not accepted in current CPU mode</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x031</b></TD>
<TD>Invalid addressing mode with current CPU setting</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x032</b></TD>
<TD>Cannot use TRn-TRn with current CPU setting</TD>
<TD>The TRx special registers were restricted to 80386 and 80486 cpus.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x033</b></TD>
<TD>Must be index or base register</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x034</b></TD>
<TD>Multiple index registers not allowed</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x035</b></TD>
<TD>Too few bits in RECORD: &lt;symbol&gt;</TD>
<TD>Size of a Record field must be &gt; 0.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x036</b></TD>
<TD>Scale factor must be 1, 2, 4 or 8</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x037</b></TD>
<TD>Cannot be used as index register: &lt;register&gt;</TD>
<TD>Index registers are restricted. In 16-bit mode, only SI and DI can be index registers.
In 32-bit mode, all general-purpose registers except ESP can be index registers.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x038</b></TD>
<TD>Base and index register differ in size</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x039</b></TD>
<TD>Expecting comma</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x040</b></TD>
<TD>ORG needs a constant or local offset</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x041</b></TD>
<TD>POP CS is not allowed</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x042</b></TD>
<TD>Only MOV can use special register</TD>
<TD>The special registers CRx, DRx and TRx can only be moved to/from general purpose registers.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x043</b></TD>
<TD>Cannot use SHORT with CALL</TD>
<TD>Distance of CALL operands must be NEAR or FAR.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x044</b></TD>
<TD>Only SHORT jump distance is allowed</TD>
<TD>Some jump instructions accept short distances only (JCXZ, JECXZ, LOOPx).</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x045</b></TD>
<TD>Syntax error</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x046</b></TD>
<TD>Prefix must be followed by an instruction</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x047</b></TD>
<TD>Syntax error: Unexpected colon</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x048</b></TD>
<TD>Operands must be the same size: &lt;size op1&gt; - &lt;size op2&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x049</b></TD>
<TD>Invalid instruction operands</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x050</b></TD>
<TD>Jump distance not possible in current CPU mode</TD>
<TD>Jcc instructions won't accept type coercions that increase the jump distance (i.e. "jz NEAR PTR <i>label</i>") if current cpu is &lt; 80386.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x051</b></TD>
<TD>Immediate data out of range</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x052</b></TD>
<TD>Can not use short or near modifiers with this instruction</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x053</b></TD>
<TD>Jump out of range by &lt;num&gt; byte(s)</TD>
<TD>A short distance must be in the range -128 to +127.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x054</b></TD>
<TD>currently not used.</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x055</b></TD>
<TD>Initializer value too large</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x056</b></TD>
<TD>Symbol already defined: &lt;symbol&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x057</b></TD>
<TD>Offset magnitude too large for specified size</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x058</b></TD>
<TD>Magnitude of offset exceeds 16 bit</TD>
<TD>This is a warning (level 3). Occurs, for example, if an instruction like "mov ax, ds:[1000000h]"
    is found in a 16-bit segment. Masm accepts without complaints, but truncates the offset to 16-bit ( JWasm does NOT truncate ).</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x059</b></TD>
<TD>Operand 2 too big</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x060</b></TD>
<TD>Operand 1 too small</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x061</b></TD>
<TD>Line too long</TD>
<TD>Size of a line ( after concatenation) is restricted to 600.
Note that Masm's line limit is 512; however, that limit is for 'original' lines only -
due to macro expansion, the 'expanded' line size may exceed the limit.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x062</b></TD>
<TD>Too many tokens in a line</TD>
<TD>The number of tokens in a line is restricted to 150.
Note that the corresponding Masm error message is 'statement too complex'.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x063</b></TD>
<TD>Symbol not defined: &lt;struct/union&gt;.&lt;member&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x064</b></TD>
<TD>Expression expected: &lt;token&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x065</b></TD>
<TD>Constant expected</TD>
<TD>A constant (numeric) value is expected in the current context. Note that a label 
- more exactly: the offset part of a label's address - is not a constant value, since
the final value is calculated by the linker ( or the OS loader ) only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x066</b></TD>
<TD>Constant operand is expected</TD>
<TD>The expression evaluator accepts a constant only in the current context.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x067</b></TD>
<TD>.ELSE clause already occured in this .IF block</TD>
<TD>An .IF block may contain 0 or 1 .ELSE clauses and it must be the last clause before .ENDIF.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x068</b></TD>
<TD>Multiple overrides</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x069</b></TD>
<TD>Segment, group or segment register expected</TD>
<TD>The operand before the colon operator (:) must be a segment, group or segment register.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x070</b></TD>
<TD>Identifier too long</TD>
<TD>Length of identifers is restricted to 247. This is a hard limit for OMF output format, and it's also
Masm's limit. For other formats, the limit may be extended by adjusting and recompiling the source code.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x071</b></TD>
<TD>Invalid operand size for instruction</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x072</b></TD>
<TD>Not supported: &lt;directive&gt;</TD>
<TD>Message is displayed if one of the follwing options is specified: OPTION READONLY, OPTION EXPR16, OPTION OLDMACROS.
Those are currently not supported.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x073</b></TD>
<TD>Size not specified, assuming: &lt;type&gt</TD>
<TD>this is a warning. &lt;type&gt; may be BYTE, WORD or DWORD. The message may occur if an
	immediate value is written to an untyped memory reference, for example:
<br><pre>mov [ebx], 1
</pre>
    JWasm makes a guess and displays this warning, while Masm will display an
    error in such cases.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x074</b></TD>
<TD>Floating-point initializer ignored</TD>
<TD></TD>
</TR>


<TR BGCOLOR="#F0F0F0">
<TD><b>x075</b></TD>
<TD>Only SHORT and NEAR jump distance is allowed</TD>
<TD>Conditional jump (Jcc) instruction destination cannot be far.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x076</b></TD>
<TD>Initializer magnitude too large for specified size</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x077</b></TD>
<TD>Segment attribute is defined already: &lt;attribute&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x078</b></TD>
<TD>Segment definition changed: %s, %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x079</b></TD>
<TD>Class name too long</TD>
<TD>Segment class names are restricted to 255 in size.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x080</b></TD>
<TD>Block nesting error: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x081</b></TD>
<TD>Segment attribute is unknown: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x082</b></TD>
<TD>Must be in segment block</TD>
<TD>Instructions and directives that generate code or data must be inside a segment block.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x083</b></TD>
<TD>Segment not defined: &lt;segment&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x084</b></TD>
<TD>Colon is expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x085</b></TD>
<TD>Invalid qualified type: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x086</b></TD>
<TD>Qualified type is expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x087</b></TD>
<TD></TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x088</b></TD>
<TD>Library name is missing</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x089</b></TD>
<TD>Cannot access label through segment registers: &lt;label&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x090</b></TD>
<TD>Line too long after expansion: &lt;line&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x091</b></TD>
<TD>Language type must be specified</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x092</b></TD>
<TD>PROC, MACRO or macro loop directive must precede LOCAL</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x093</b></TD>
<TD>Cannot nest procedures</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x094</b></TD>
<TD>VARARG requires C calling convention</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x095</b></TD>
<TD>Multiple .MODEL directives, .MODEL ignored</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x096</b></TD>
<TD>Model is not declared</TD>
<TD>Without a model, simplified segment directives ( .CODE, .DATA, .CONST, .DATA?, .STACK, .FARDATA and .FARDATA? )
and directives .STARTUP, .EXIT cannot be used.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x097</b></TD>
<TD>Backquote missing: `&lt;identifier&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x098</b></TD>
<TD>COMMENT delimiter expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x099</b></TD>
<TD>END directive required at end of file</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x100</b></TD>
<TD>Nesting level too deep</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x101</b></TD>
<TD>Macro nesting level too deep</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x102</b></TD>
<TD>Symbol not defined : &lt;symbol&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x103</b></TD>
<TD></TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x104</b></TD>
<TD>No filename specified.</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x105</b></TD>
<TD>Out of Memory</TD>
<TD>This is a fatal error. With the 8086-version of jwasm, JWASMR, you'll see this error 
if you try to assemble something that contains a few thousand symbols. The 32- or 64-bit
versions of jwasm should always have enough memory on modern machines.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x106</b></TD>
<TD>Cannot open file: "&lt;file&gt;" [&lt;error code&gt;]</TD>
<TD>Error code ENOENT means "file not found". Other error codes are displayed as numbers</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x107</b></TD>
<TD>Cannot close file: &lt;file&gt; [&lt;error code&gt;]</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x108</b></TD>
<TD>File write error: &lt;file&gt; [&lt;error code&gt;]</TD>
<TD>Usually happens if output media is read-only or full.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x109</b></TD>
<TD>Invalid command-line option: &lt;option&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x110</b></TD>
<TD>Internal error in &lt;source file&gt;(&lt;line&gt;)</TD>
<TD>This error shouldn't be seen in the release version. It's displayed if the
internal assert() function is called, which usually is done when a "virtually impossible"
error condition has occurred.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x111</b></TD>
<TD>Expecting closing square bracket</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x112</b></TD>
<TD>Expecting file name</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x113</b></TD>
<TD>Too many errors</TD>
<TD>Use <A HREF="#CMDOPTE">commandline option -e</A> to set the max. number of errors that are displayed</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x114</b></TD>
<TD>forced error &lt;message&gt;</TD>
<TD>Generic "forced error" message</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x115</b></TD>
<TD>forced error: Value not equal to 0: &lt;value&gt; &lt;text&gt;</TD>
<TD>Error emitted by the .ERRNZ directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x116</b></TD>
<TD>forced error: Value equal to 0: &lt;value&gt; &lt;text&gt;</TD>
<TD>Error emitted by the .ERRE directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x117</b></TD>
<TD>forced error: symbol defined: &lt;symbol&gt;</TD>
<TD>Error emitted by the .ERRDEF directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x118</b></TD>
<TD>forced error: symbol not defined: &lt;symbol&gt;</TD>
<TD>Error emitted by the .ERRNDEF directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x119</b></TD>
<TD>forced error: string blank : &lt;string&gt;</TD>
<TD>Error emitted by the .ERRB directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x120</b></TD>
<TD>forced error: string not blank : &lt;string&gt;</TD>
<TD>Error emitted by the .ERRNB directive.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x121</b></TD>
<TD>forced error: strings not equal : &lt;string&gt; : &lt;string&gt;</TD>
<TD>Error emitted by the .ERRDIF and .ERRDIFI directives.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x122</b></TD>
<TD>forced error: strings equal : &lt;string&gt; : &lt;string&gt;</TD>
<TD>Error emitted by the .ERRIDN and .ERRIDNI directives.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x123</b></TD>
<TD>&lt;file&gt;(&lt;line&gt;): Included by</TD>
<TD>Additional error information if error occured in an include file.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x124</b></TD>
<TD>&lt;file&gt;(&lt;line&gt;)[&lt;macro&gt;]: Macro called from</TD>
<TD>Additional error information if error occured inside a macro.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x125</b></TD>
<TD>&lt;file&gt;(&lt;line&gt;): iteration &lt;iteration&gt;: Macro called from</TD>
<TD>Additional error information if error occured inside a loop macro (FOR, FORC, REPEAT, ...).</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x126</b></TD>
<TD>&lt;file&gt;(&lt;line&gt;): Main line code</TD>
<TD>Additional error information if error occured inside an include file or a macro.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x127</b></TD>
<TD>Extending jump</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x128</b></TD>
<TD>Directive ignored: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x129</b></TD>
<TD>number must be a power of 2</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x130</b></TD>
<TD>Incompatible with segment alignment: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x131</b></TD>
<TD>Segment expected: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x132</b></TD>
<TD>Incompatible CPU mode for 32-bit segment</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x133</b></TD>
<TD>Far call is converted to near call.</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x134</b></TD>
<TD>CPU option %s is not valid for selected CPU.</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x135</b></TD>
<TD>Segment '%s' is in another group already</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x136</b></TD>
<TD>Symbol type conflict: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x137</b></TD>
<TD>Conflicting parameter definition: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x138</b></TD>
<TD>PROC and PROTO calling convention conflict</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x139</b></TD>
<TD>Non-benign %s redefinition: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x140</b></TD>
<TD>Too many bits in RECORD: %s</TD>
<TD>Size of a RECORD is limited to 32 bits for 16-/32-bit code and 64 bits for 64-bit code.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x141</b></TD>
<TD>Statement not allowed inside structure definition</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x142</b></TD>
<TD>Unmatched block nesting: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x143</b></TD>
<TD>Symbol redefinition: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x144</b></TD>
<TD>Text item required</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x145</b></TD>
<TD>INVOKE argument type mismatch: argument %u</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x146</b></TD>
<TD>Too few arguments to INVOKE: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x147</b></TD>
<TD>VARARG parameter must be last</TD>
<TD>The macro parameter qualifier VARARG can only be added to the last parameter.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x148</b></TD>
<TD>LABEL parameter must be first</TD>
<TD>The macro parameter qualifier LABEL ( JWasm extension ) can only be added to the first parameter.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x149</b></TD>
<TD>Too many arguments in macro call: %s</TD>
<TD>This is a warning. Macro is invoked with more arguments than expected.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x150</b></TD>
<TD>Missing operator in expression</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x151</b></TD>
<TD>Unexpected literal found in expression: %s</TD>
<TD>Literals enclosed in &lt;&gt; or {} are items processed by the preprocessor or to
initialize "structured" data items. If they're used otherwise, this error will occur.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x152</b></TD>
<TD>Initializer must be a string or single item: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x153</b></TD>
<TD>Too many initial values for structure: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x154</b></TD>
<TD>Too many initial values for array: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x155</b></TD>
<TD>String or text literal too long</TD>
<TD>Length of text literals is limited to 568. Note that this differs from Masm's limit of 255.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x156</b></TD>
<TD>PROLOGUE must be macro function</TD>
<TD>The user-defined prologue macro must be a macro function, that is, there must
be an EXITM somewhere inside that returns a literal.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x157</b></TD>
<TD>EPILOGUE must be macro procedure: %s</TD>
<TD>The user-defined epilogue macro must be a macro procedure, that is, there must NOT
be an EXITM somewhere inside that returns a literal.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x158</b></TD>
<TD>Reserved word expected</TD>
<TD>OPTION NOKEYWORD and OPTION RENAMEKEYWORD both expect a reserved word as argument.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x159</b></TD>
<TD>INVOKE requires prototype for procedure</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x160</b></TD>
<TD>Invalid type for data declaration: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x161</b></TD>
<TD>Operand must be RECORD type or field</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x162</b></TD>
<TD>Unmatched macro nesting</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x163</b></TD>
<TD>Empty (null) string</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x164</b></TD>
<TD>No segment information to create fixup: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x165</b></TD>
<TD>Register value overwritten by INVOKE</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x166</b></TD>
<TD>Missing quotation mark in string</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x167</b></TD>
<TD>Divide by zero in expression</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x168</b></TD>
<TD>General Failure</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x169</b></TD>
<TD>Cannot have implicit far jump or call to near label</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x170</b></TD>
<TD>Invalid use of register</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x171</b></TD>
<TD>Distance invalid for current segment</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x172</b></TD>
<TD>Initializer magnitude too large: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x173</b></TD>
<TD>Cannot add two relocatable labels</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x174</b></TD>
<TD>Cannot define as public or external: &lt;symbol_name&gt;</TD>
<TD>Text macros, macros, stack variables, structure fields or segment/groups cannot be
public or external.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x175</b></TD>
<TD>Positive value expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x176</b></TD>
<TD>FAR not allowed in FLAT model COMM variables</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x177</b></TD>
<TD>Too many arguments to INVOKE</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x178</b></TD>
<TD>Directive must appear inside a macro</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x179</b></TD>
<TD>Invalid type expression</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x180</b></TD>
<TD>Cannot declare scoped code label as PUBLIC: &lt;label&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x181</b></TD>
<TD>Invalid radix tag</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x182</b></TD>
<TD>Instruction operand must have size</TD>
<TD>The instruction allows operands with more than just one size, and the wanted size
cannot be guessed from the current operands.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x183</b></TD>
<TD>Use of register assumed to ERROR</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x184</b></TD>
<TD>Instructions and initialized data not supported in &lt;seg_type&gt; segments</TD>
<TD>&lt;seg_type&gt; may be BSS or AT. Such segments don't have data.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x185</b></TD>
<TD>Literal expected after '='</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x186</b></TD>
<TD>No 4k Page-aligned segments in MS386 OMF</TD>
<TD>A 4K page-aligned segment isn't compatible with MS OMF format, it's a Phar Lab extension.
This warning won't appear in the standard version.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x187</b></TD>
<TD></TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x188</b></TD>
<TD>Operand must be relocatable</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x189</b></TD>
<TD>Constant or relocatable label expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x190</b></TD>
<TD>[ELSE]IF2/.ERR2 not allowed, single-pass assembler</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x191</b></TD>
<TD>Expression too complex for UNTILCXZ</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x192</b></TD>
<TD>Operands must be in same segment</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x193</b></TD>
<TD>Invalid use of external symbol: &lt;symbol_name&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x194</b></TD>
<TD>For -coff leading underscore required for start label: &lt;start_label&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x195</b></TD>
<TD>Invalid command-line value, default is used: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x196</b></TD>
<TD>Unknown fixup type: %u at &lt;segment&gt;.&lt;offset&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x197</b></TD>
<TD>Unsupported fixup type for &lt;format&gt;: &lt;type&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x198</b></TD>
<TD>Invalid fixup type for &lt;format&gt; &lt;type&gt; at location &lt;segment&gt;.&lt;offset&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x199</b></TD>
<TD>Syntax error in control-flow directive</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x200</b></TD>
<TD>Invalid .model parameter for flat model</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x201</b></TD>
<TD>Output format doesn't support externals: &lt;symbol&gt;</TD>
<TD>In formats BIN and MZ all references must be local to the module.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x202</b></TD>
<TD>Invalid start label for -bin</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x203</b></TD>
<TD>No start label defined</TD>
<TD>Warning, format MZ only: MZ-binaries usually have a start label.
In some cases (i.e. overlays) a missing start label may be ok.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x204</b></TD>
<TD>No stack defined</TD>
<TD>Warning, format MZ only: MZ-binaries usually have a stack.
In some cases (i.e. overlays) a missing stack may be ok.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x205</b></TD>
<TD>Invalid alignment - value must be 2^n (n=4..15)</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x206</b></TD>
<TD>Index value past end of string: &lt;value&gt;</TD>
<TD>The index argument of SUBSTR or INSTR is beyond the string argument length</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x207</b></TD>
<TD>Count value too large</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x208</b></TD>
<TD>Count must be positive or zero</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x209</b></TD>
<TD>Syntax error: &lt;item&gt;</TD>
<TD>The parser found an item that has no meaning in the current context</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x210</b></TD>
<TD></TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x211</b></TD>
<TD>Model must be FLAT</TD>
<TD>In 64-bit mode, or if output format is -pe, there's no segmented model available.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x212</b></TD>
<TD>Must use floating-point initializer</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x213</b></TD>
<TD>ORG directive not allowed in unions</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x214</b></TD>
<TD>Struct alignment must be 1, 2, 4, 8, 16 or 32</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x215</b></TD>
<TD>Structure cannot be instanced</TD>
<TD>A structure that has size 0 or that contains an ORG directive cannot be instanced.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x216</b></TD>
<TD>Missing angle bracket or brace in literal</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x217</b></TD>
<TD>Nondigit in number: &lt;number&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x218</b></TD>
<TD>16bit fixup for 32bit label: &lt;symbol&gt;</TD>
<TD>A warning that the generated code might not do what is expected.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x219</b></TD>
<TD>Too many macro placeholders</TD>
<TD>The number of parameters and locals for a macro must not exceed 256</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x220</b></TD>
<TD>Missing macro argument: %s, parameter %u</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x221</b></TD>
<TD>Doesn't work with 32-bit segments: &lt;directive&gt;</TD>
<TD>Directives .STARTUP and .EXIT work for 16-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x222</b></TD>
<TD>Segment exceeds 64k limit: %s</TD>
<TD>In MZ format, 16-bit segments are restricted to 64k.<TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x223</b></TD>
<TD>Not supported with OMF format: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x224</b></TD>
<TD>Not supported with current output format: %s</TD>
<TD>The directive or feature isn't supported by all formats. For example, segment-related
directives or attributes won't make much sense for flat formats like COFF or ELF.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x225</b></TD>
<TD>Unknown default prologue argument: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x226</b></TD>
<TD>LOADDS ignored in flat model</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x227</b></TD>
<TD>Missing right parenthesis in expression</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x228</b></TD>
<TD>Invalid operand for &lt;operator&gt;: &lt;operand&gt;</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x229</b></TD>
<TD>Structure improperly initialized: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x230</b></TD>
<TD>Expected: %s</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x231</b></TD>
<TD>Invalid data initializer</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x232</b></TD>
<TD>Expected data label</TD>
<TD>Some operators ( LENGTH, SIZE ) work with data labels only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x233</b></TD>
<TD>Expression must be a code address</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x234</b></TD>
<TD>-n Option needs a valid name parameter</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x235</b></TD>
<TD>Constant value too large: &lt;value&gt;</TD>
<TD>the value of the constant doesn't fit in 64 or - if it is a number to be assigned to a 
symbolic constant - 32 bits.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x236</b></TD>
<TD>Text macro was used before definition</TD>
<TD>this is a warning only. However, using text macros before they have been defined will force
    JWasm to do a full second pass, which increases assembly time.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x237</b></TD>
<TD>Offset size incompatible with current segment</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x238</b></TD>
<TD>Instruction form requires 80386</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x239</b></TD>
<TD>Group/Segment offset size conflict: &lt;group offset&gt; - &lt;segment offset&gt;</TD>
<TD>Segments within a group must all have the same offset size.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x240</b></TD>
<TD>Assembly passes reached: &lt;passes&gt;</TD>
<TD>Although this is a warning only it usually indicates a severe problem.
The assembler is very probably unable to calculate "final" values of all labels and has
to be terminated by pressing Ctrl-C.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x241</b></TD>
<TD>Filename parameter must be enclosed in &lt;&gt; or quotes</TD>
<TD>The INCBIN directive requires delimiters for its filename.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x242</b></TD>
<TD>Start address on END directive ignored with .STARTUP</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x243</b></TD>
<TD>Invalid symbol type in expression: &lt;symbol&gt;</TD>
<TD>The expression evaluator has encountered a symbol that is meaningless in expressions, for
example a (text) macro.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x244</b></TD>
<TD>Missing right parenthesis</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x245</b></TD>
<TD>Directive must be in control block</TD>
<TD>.ELSE, .ELSEIF and .ENDIF are valid inside .IF-blocks,  .BREAK, .CONTINUE may occur
inside .WHILE- or .REPEAT-blocks, .ENDW needs a preceding .WHILE and .UNTIL needs a
preceding .REPEAT.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x246</b></TD>
<TD>Expected: memory model</TD>
<TD>the .MODEL directive needs at least one parameter, the memory model.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x247</b></TD>
<TD>Type is wrong size for register</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x248</b></TD>
<TD>IF[n]DEF expects a plain symbol as argument</TD>
<TD>this is a warning.
    Masm accepts any expression as argument for directives [ELSE]IF[N]DEF, but
    the result probably isn't always what has been expected. 
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x249</b></TD>
<TD>Jump destination must specify a label</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x250</b></TD>
<TD>Ignored: &lt;attribute&gt;</TD>
<TD>An attribute or parameter of a directive was found, but not handled.
See <A HREF="#10">Known Bugs and missing Features</A> for details about what features aren't implemented yet.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x251</b></TD>
<TD>Missing argument for cmdline option</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x252</b></TD>
<TD>Invalid coprocessor register</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x253</b></TD>
<TD>Registers AH-DH may not be used with SPL-DIL or R8-R15</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x254</b></TD>
<TD>.ENDPROLOG found before EH directives</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x255</b></TD>
<TD>Missing FRAME in PROC, no unwind code will be generated</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x256</b></TD>
<TD>Bad alignment for offset in unwind code</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x257</b></TD>
<TD>Nonzero value expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x258</b></TD>
<TD>Size of prolog too big, must be < 256 bytes</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x259</b></TD>
<TD>Missing .ENDPROLOG: %s</TD>
<TD>64-bit only.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x260</b></TD>
<TD>.SAFESEH argument must be a PROC</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x261</b></TD>
<TD>Directive ignored without -%s switch</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x262</b></TD>
<TD>ELF GNU extensions (8/16-bit relocations) used</TD>
<TD>This is a warning only. The extensions are not "official", but the GNU linker LD will
understand them.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x263</b></TD>
<TD>Syntax error in expression</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x264</b></TD>
<TD>Macro label not defined: %s</TD>
<TD>The target of a GOTO must be within the very same macro.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x265</b></TD>
<TD>Procedure argument or local not referenced: %s</TD>
<TD>This warning is displayed only if at least -W3 is specified.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x266</b></TD>
<TD>Group definition too large, truncated: &lt;group_name&gt;</TD>
<TD>The size of the OMF record that is to define a group would exceed 4 kB. However, to see this
error you'll have to define a group that is to comprise more than 1000 segments, </TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x267</b></TD>
<TD>COMM variable exceeds 64K: &lt;variable&gt;</TD>
<TD>in 16-bit, the size of a COMM variable is restricted to 64 kB.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x268</b></TD>
<TD>Must be public or external: %s</TD>
<TD>Names that are to be known by the linker must be public or external.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x269</b></TD>
<TD>parameter/local name is reserved word: %s</TD>
<TD>This is a warning. The names of macro parameters or locals have highest priority and
hence the reserved word will become inaccessible within the macro.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x270</b></TD>
<TD>real or BCD number not allowed</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x271</b></TD>
<TD>structure field expected</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x272</b></TD>
<TD>Constant value too large: &lt;value&gt;</TD>
<TD>the value of the constant doesn't fit in 64 or - if it is a number to be assigned to a 
symbolic constant - 32 bits.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x273</b></TD>
<TD>ELSE clause already occured in this IF block</TD>
<TD>An IF block may contain 0 or 1 ELSE clauses and it must be the last clause before ENDIF.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x274</b></TD>
<TD>Illegal use of segment register</TD>
<TD></TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x275</b></TD>
<TD>Group exceeds 64K: &lt;group&gt;</TD>
<TD>MZ format only: a group that contains 16-bit segments cannot be larger than 64 kB, because the 
group must fit into a physical segment. Also, due to how a group is located in the binary, the max.
size may be even up to 15 bytes smaller than 64 kB!</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x276</b></TD>
<TD>EXPORT must be FAR: &lt;symbol&gt;</TD>
<TD>A 16-bit procedure that is to be exported must be declared with the FAR distance attribute.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x277</b></TD>
<TD>Start label not in a 16-bit segment</TD>
<TD>MZ format only: the start label is in a 32- or 64-bit segment.
The resulting MZ binary won't run without further modification, i.e. adding a DOS-extender stub.</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x278</b></TD>
<TD>ADDR32 fixup to '&lt;symbol&gt;' at location &lt;segment&gt;.&lt;offset&gt;</TD>
<TD>64-bit PE format only: a 32-bit fixup was detected, but base address is above or equal 0x80000000.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x279</b></TD>
<TD>64-bit label referenced with 32-bit fixup</TD>
<TD>
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x280</b></TD>
<TD>Too many segments/sections defined for output format</TD>
<TD>For OMF, max. number of segments is 32767. For COFF, max. number of sections is 65535.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x281</b></TD>
<TD>Object format doesn't support anonymous fixups, location: &lt;offset&gt;</TD>
<TD>Anonymous fixups are possible for the OMF object format only.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x282</b></TD>
<TD>Segment/Section ignored in binary formats</TD>
<TD>This is a warning. Informational sections for the linker are ignored for binary formats.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x283</b></TD>
<TD>Opcode size suffix ignored for segment registers</TD>
<TD>This is a warning if opcodes PUSHW/PUSHD are used to push segment registers. The expectation
    might be that an appropriate size suffix (0x66) is generated by the assembler, but this assumption is incorrect.
</TD>
</TR>

<TR BGCOLOR="#F0F0F0">
<TD><b>x284</b></TD>
<TD>Prologue not at PROC start</TD>
<TD>This is a warning, caused for example by data definition directives at the procedure's start. This
    is unusual, but accepted ( by JWasm and Masm ). It might cause unexpected results, though.
</TD>
</TR>

</TABLE>

<H1 ID="AD"> Appendix D. Differences between Masm 6 and Masm 8 </H1>

This is not strictly JWasm-related, but since a lot of documentation that can be found about
Masm still refers to Masm v6 or Masm v6.1 only, it's useful to list the differences.

<UL>
<LI>default output format has been changed from OMF to COFF in Masm 8.</LI>

<LI>expression evaluator calculations are done in 64-bit instead of 32-bit.
This is not always reflected in the listing file, where the values may be truncated to 32-bit.</LI>
<LI>some segment attributes have been added in Masm 8 to cover the COFF section attribute bits. These are:
<UL>
<LI>INFO</LI>
<LI>DISCARD</LI>
<LI>NOCACHE</LI>
<LI>NOPAGE</LI>
<LI>SHARED</LI>
<LI>EXECUTE</LI>
<LI>READ</LI>
<LI>WRITE</LI>
<LI>ALIAS</LI>
<LI>ALIGN</LI>
</UL>
</LI>
<LI>the -safeseh commandline option and the .SAFESEH directive have been added in Masm 8.</LI>

<LI>Masm 8 understands a few new data types:
<UL>
<LI>OWORD - 128-bit integer</LI>
<LI>MMWORD - 64-bit data type for MMX</LI>
<LI>XMMWORD - 128-bit data type for SSE</LI>
</UL>
</LI>

<LI>several unary operators are new for Masm 8:
<UL>
<LI>LOW32 - returns the lower 32-bit of an expression</LI>
<LI>HIGH32 - returns the upper 32-bit of an expression</LI>
<LI>IMAGEREL - returns the image relative offset of an expression (aka RVA). COFF format only.</LI>
<LI>SECTIONREL - returns the section relative offset of an expression. COFF format only.</LI>
</UL>
Please note: LOW32 and HIGH32 operators won't accept plain numbers with values that exceed 32-bits.
</LI>

<LI>Masm 8 understands instruction sets up to SSE3. The last version of Masm 6, version 6.15, supports SSE2 only.
Masm 8 also understands Intel's VMX and AMD's SVM extensions ( x86 virtualization ).
</LI>
<LI>Masm 8 needs at least Windows 2000, it won't run on Windows 9x (without hacks).</LI>
<LI>Masm 8 needs a MS VC runtime dll - MSVCR80.DLL - to run, while Masm 6 was a stand-alone binary.</LI>
<LI>Finally, Masm 8 fixes some bugs and introduces a few new ones. One of the new bugs is that Masm 8
has problems with wildcards in filenames; entering <pre>ml.exe -c *.asm</pre> to assemble all assembly
files in a directory won't work as expected.</LI>
</UL>

<H1 ID="AE"> Appendix E. Restrictions of precompiled 16-bit Binary JWASMR.EXE </H1>

    JWASMR lacks some features of the other precompiled binaries:
<UL>
<LI>no support for long filenames.</LI>
<LI>no support for Open Watcom's fastcall register convention.</LI>
<LI>supports OMF, BIN and MZ <A HREF="#CHAPOUTPUTFORMATS">output formats</A> only.</LI>
<LI>no support for 64-bit, SSSE3, SSE4 and AVX.</LI>
<LI>no support for OPTION variants that are specific for COFF, ELF or 64-bit.</LI>
<LI>no support for <A HREF="#OPTCODEVIEW">OPTION CODEVIEW</A> directive.</LI>
<LI>no support for directive LABEL's <A HREF="#LABELARRAY">array size syntax extension</A>.</LI>
</UL>
    Since the JWasm source is available, one may enable this or that feature if
    really needed, though.

<H1 ID="AF"> Appendix F. Additional Features of JWasm's Debug Version </H1>

    Note: there are no precompiled debug versions of JWasm available. Such versions
    have to be created from the source code. See the comments in the makefiles how
    to do that.
<P>
    The debug version offers the following additional commandline options:
<TABLE CELLPADDING="4" CELLSPACING="1">
<TR BGCOLOR="#E8E8E8"><TD>-af</TD>  <TD> Display all files used in assembly process </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-ce</TD>  <TD> Cause an exception </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-dm</TD>  <TD> Display all messages </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-dr</TD>  <TD> Display reserved words </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-drh</TD> <TD> Display reserved words hash table </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-ds</TD>  <TD> Display global symbols </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-dsh</TD> <TD> Display global symbols hash table </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-dt</TD>  <TD> Display debug trace </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-ls</TD>  <TD> Display preprocessed line storage </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-nbp</TD> <TD> Disable back-patching </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-nfp</TD> <TD> Do full subsequent passes ( disables "fastpass" ) </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-pm=&lt;n&gt;</TD> <TD> Stop assembly after <i>n</i> passes </TD></TR>
<TR BGCOLOR="#E8E8E8"><TD>-sp</TD> <TD> Skip preprocessor step </TD></TR>
</TABLE>

</BODY>
</HTML>
